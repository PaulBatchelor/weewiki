#+TITLE: zet
* Overview
Zet is a simple zettelkasten interface implemented in
weewiki.

Compared to the wiki, zet is more granular. Instead of
hypertext documents connected by links, you have things
connected to things. It is encouraged that information
be more atomic and bite-sized.

The zet will occupy a new SQLite table called "wikizet".
Like the main wiki, it too will have a key/value schema.
The difference in this case is that keys will not be unique.
This allows one key to point to multiple things.

A key is expected to be a uuid following the uuid4 specs.
This is generated courtesy of the uuid4 library by rxi. the
values are strings that can mean any number of things based
on the first character:

a "#" indicates that reference to another uuid. this is how
connections are made.

a "/" inidicates the start of a file such as /foo/bar.txt.
The intent of this is to use it with sqlar as a way to
reference and link files into weewiki.

a "!" indicates a reference to a wiki page. This follows
the adopted convention I've been using to reference wiki
pages in my twtxt messages.

a ">" explicitely indicates a string value.

values in the zet table optionally include a timestamp
value. This allows the zet to be used as a logging and
microblogging interface along the lines of twtxt.
* Tangled Files
=zet.c= and =zet.h= are the generated files.

#+NAME: zet.c
#+BEGIN_SRC c :tangle zet.c
#include <stdio.h>
#include <sqlite3.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include "uuid4/uuid4.h"
#include "weewiki.h"
#include "zet.h"
#include "linenoise/linenoise.h"
<<static_funcdefs>>
<<funcs>>
#+END_SRC

#+NAME: zet.h
#+BEGIN_SRC c :tangle zet.h
#ifndef ZET_H
#define ZET_H
<<typedefs>>
<<funcdefs>>
<<structs>>
#endif
#+END_SRC
* Low Level Operations
** UUIDs
A universally unique identifer (UUID) is used to label
every item in the zet. The UUIDs are generated courtesy
of the =uuid4= library by =rxi=, included inside of
the weewiki project.
*** UUID struct
A full UUID contained inside of a struct called
=wwzet_uuid=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wwzet_uuid wwzet_uuid;
#+END_SRC

This UUID contains a char of 37 bytes:
36 for the UUID (including dashes) plus the null terminator.

#+NAME: structs
#+BEGIN_SRC c
struct wwzet_uuid {
    char str[37];
};
#+END_SRC
*** (re)-initializing a UUID
The UUID is initialized with the function
=wwzet_uuid_init=. This will set the UUID to be
=00000000-0000-4000-8000-000000000000=, a valid
but zeroed UUID4.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_uuid_init(wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_uuid_init(wwzet_uuid *uuid)
{
    int i;
    static const char *zero =
        "00000000-0000-4000-8000-000000000000";

    for (i = 0; i < 36; i++) uuid->str[i] = zero[i];
    uuid->str[36] = 0;
}
#+END_SRC
*** Initializing the uuid4 RNG
Before generating a new UUID, the RNG must be
initialized with =wwzet_uuid_rng_init=.

This makes a call to =uuid4_init=.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_uuid_rng_init(void);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_uuid_rng_init(void)
{
    uuid4_init();
}
#+END_SRC
*** UUID generation
Create a new UUID with =wwzet_uuid_generate=. This uses
the uuid version 4 protocol, which means it is randomly
generated. This assumes the RNG has been initialized
already.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_uuid_generate(wwzet_uuid *uuid);
#+END_SRC

This function calls =uuid4_generate= under the hood, and
then stores the output to the =wwzet_uuid= variable
=uuid=.

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_uuid_generate(wwzet_uuid *uuid)
{
    uuid4_generate(uuid->str);
}
#+END_SRC
*** UUID expansion/validation
=wwzet_uuid_expand= will check if a partial UUID exists in
the zettelkasten table, and expand to full UUID value.
The partial value is provided as a null-terminated C string.

The number of matches is returned. Anything not equal to
1 is considered an error.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_uuid_expand(weewiki_d *ww,
                      const char *partial,
                      int sz,
                      wwzet_uuid *uuid);
#+END_SRC

The following SQLite3 statement is used:

#+BEGIN_SRC sqlite
SELECT UUID, COUNT(DISTINCT UUID) from wikizet where UUID LIKE(?1);
#+END_SRC

Where "?1" is the partial match.

This query will return a single row with the first found
wikizet, and the number of matches.

Actions will only happen when there is exactly 1 match.
This involves copying over the UUID value into the
variable.

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_uuid_expand(weewiki_d *ww,
                      const char *partial,
                      int sz,
                      wwzet_uuid *uuid)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    char *matchstr;
    int nmatches;

    matchstr = calloc(1, sz + 2);

    strcpy(matchstr, partial);
    matchstr[sz] = '%';

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "SELECT UUID, COUNT(DISTINCT UUID) FROM wikizet "
                       "WHERE UUID LIKE(?1);",
                       -1, &stmt, NULL);

    sqlite3_bind_text(stmt, 1, matchstr, sz + 1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        free(matchstr);
        sqlite3_finalize(stmt);
        return -1;
    }

    nmatches = sqlite3_column_int(stmt, 1);

    if (nmatches == 1) {
        int i;
        const char *str;
        str = (const char *)sqlite3_column_text(stmt, 0);

        for (i = 0; i < 36; i++) uuid->str[i] = str[i];
    }

    free(matchstr);
    sqlite3_finalize(stmt);
    return nmatches;
}
#+END_SRC
** Create Zet Entry
=wwzet_entry= creates a generic zet entry given a message
and timestamps it based on the current system time.

If =uuid= is not NULL, the generated UUID is saved here.
It is assumed the uuid RNG is initialized already before
calling this function.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_entry(weewiki_d *ww,
                const char *msg,
                int sz,
                wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_entry(weewiki_d *ww,
                const char *msg,
                int sz,
                wwzet_uuid *uuid)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    wwzet_uuid id;
    int rc;

    wwzet_uuid_init(&id);
    db = weewiki_db(ww);
    wwzet_uuid_generate(&id);

    sqlite3_prepare_v2(db,
                       "INSERT INTO "
                       "wikizet(time, UUID, value)"
                       "VALUES(datetime(), ?1, ?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, id.str, -1, NULL);
    sqlite3_bind_text(stmt, 2, msg, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        return 1;
    }

    if (uuid != NULL) *uuid = id;

    sqlite3_finalize(stmt);
    return 0;
}
#+END_SRC
** Create Zet Entry (With Symbol)
The function =wwzet_entry_withsymbol= wraps around
=wwzet_entry= to create a new timestamped entry and
prepends it with a single-character symbol.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_entry_withsymbol(weewiki_d *ww,
                           char c,
                           const char *msg,
                           int sz,
                           wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_entry_withsymbol(weewiki_d *ww,
                           char c,
                           const char *msg,
                           int sz,
                           wwzet_uuid *uuid)
{
    char *val;
    int rc;

    val = malloc(sz + 2);
    val[0] = c;

    strncpy(&val[1], msg, sz);

    val[sz + 1] = '\0';

    rc = wwzet_entry(ww, val, sz + 1, uuid);

    free(val);
    return rc;
}
#+END_SRC
** Insert an Entry
The function =wwzet_insert= will perform a low-level
insert command into the wikizet table. The timestamp,
uuid, and value should already be generated or known.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_insert(weewiki_d *ww,
                  const char *timestamp, int tlen,
                  const char *uuid, int ulen,
                  const char *value, int vlen);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_insert(weewiki_d *ww,
                  const char *timestamp, int tlen,
                  const char *uuid, int ilen,
                  const char *value, int vlen)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "INSERT into wikizet(time,uuid,value) "
                       "VALUES(?1,?2,?3);",
                       -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, timestamp, tlen, NULL);
    sqlite3_bind_text(stmt, 2, uuid, ilen, NULL);
    sqlite3_bind_text(stmt, 3, value, vlen, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
    }

    sqlite3_finalize(stmt);
}
#+END_SRC
** Create Zet Message
The function =wwzet_message= will create a
timestamped entry with a message in the zet table
with a new UUID.

What is required is the main weewiki data, message, as well
as the message length. The resulting UUID will get placed in
the supplied UUID pointer if it is not NULL.

Be sure to open the database and initialize the UUID4 RNG
before calling this.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_message(weewiki_d *ww,
                  const char *msg,
                  int sz,
                  wwzet_uuid *uuid);
#+END_SRC

Under the hood, this will generate a UUID and create an
insert SQLite statement using the SQLite API.

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_message(weewiki_d *ww,
                  const char *msg,
                  int sz,
                  wwzet_uuid *uuid)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    wwzet_uuid id;
    int rc;
    char *val;

    val = malloc(sz + 2);

    val[0] = '>';

    strcpy(&val[1], msg);
    wwzet_uuid_init(&id);
    db = weewiki_db(ww);
    wwzet_uuid_generate(&id);

    sqlite3_prepare_v2(db,
                       "INSERT INTO "
                       "wikizet(time, UUID, value)"
                       "VALUES(datetime(), ?1, ?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, id.str, -1, NULL);
    sqlite3_bind_text(stmt, 2, val, sz + 1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        free(val);
        return 1;
    }

    if (uuid != NULL) *uuid = id;

    free(val);
    sqlite3_finalize(stmt);
    return 0;
}
#+END_SRC
** Create Zet Link
The function =wwzet_link= will link UUID A to
UUID B.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_link(weewiki_d *ww, wwzet_uuid *a, wwzet_uuid *b);
#+END_SRC

A link is created by creating a new entry using A's UUID,
and having the value be the UUID of B. A UUID is prepended
with a '#'.

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_link(weewiki_d *ww, wwzet_uuid *a, wwzet_uuid *b)
{
    char *addr;

    addr = calloc(1, 38);
    addr[0] = '#';
    strcpy(&addr[1], b->str);
    wwzet_insert(ww, NULL, 0, a->str, 36, addr, 37);
    free(addr);
}
#+END_SRC
** Create Zet File
A file entry is created with =wwzet_file=.

An inserted file is not actually the file, but just
a file path, prepended with a forward slash =/=.
Presumably, this would link to an entry in the SQLar table
(which do not have leading slashes). Thus, an entry
=/test/foo.txt= would have a corresponding SQLar file
=test/foo.txt=.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_file(weewiki_d *ww,
               const char *filename,
               int sz,
               wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_file(weewiki_d *ww,
               const char *filename,
               int sz,
               wwzet_uuid *uuid)
{
    return wwzet_entry_withsymbol(ww, '/', filename, sz, uuid);
}
#+END_SRC
** Create Zet Group
A group entry is created with =wwzet_group=.

Groups are used with the crate interface, and are used
to link files to specific sqlar archives.

Groups are prefixed with '@'.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_group(weewiki_d *ww,
               const char *group,
               int sz,
               wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_group(weewiki_d *ww,
               const char *filename,
               int sz,
               wwzet_uuid *uuid)
{
    return wwzet_entry_withsymbol(ww, '@', filename, sz, uuid);
}
#+END_SRC
* Command Line Operations
** top-level processor
The entry point for the top-level CLI is done with
=ww_zet=.

#+NAME: funcdefs
#+BEGIN_SRC c
int ww_zet(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int ww_zet(int argc, char *argv[])
{
    if (argc <= 1) {
        fprintf(stderr, "Zet: supply a command\n");
        return 1;
    }

    argv++; argc--;

    if (!strcmp(argv[0], "say")) {
        return p_say(argc, argv);
    } else if (!strcmp(argv[0], "export")) {
        return p_export(argc, argv);
    } else if (!strcmp(argv[0], "import")) {
        return p_import(argc, argv);
    } else if (!strcmp(argv[0], "rebuild")) {
        return p_rebuild(argc, argv);
    } else {
        fprintf(stderr, "Could not find command '%s'\n", argv[1]);
    }

    return 1;
}
#+END_SRC
** say
creates a new UUID with a timestamped message. Any arguments
provided are expected to be partial UUIDs of pre-existing
zet items.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_say(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_say(int argc, char *argv[])
{
    char *line;

    line = linenoise("say: ");

    if (line != NULL) {
        weewiki_d *ww;
        wwzet_uuid uuid;
        int rc;

        ww = malloc(weewiki_sizeof());
        weewiki_init(ww);
        weewiki_open(ww, weewiki_dbname_get());

        wwzet_uuid_rng_init();
        wwzet_uuid_init(&uuid);
        rc = wwzet_message(ww, line, strlen(line), &uuid);

        if (!rc) printf("%s\n", uuid.str);

        if (argc > 1) {
            wwzet_uuid res;
            int p;

            for (p = 1; p < argc; p++) {
                const char *part;
                int m;
                part = argv[p];

                wwzet_uuid_init(&res);
                m = wwzet_uuid_expand(ww, part, strlen(part), &res);

                if (m == 0) {
                    fprintf(stderr, "could not expand '%s'\n", part);
                } else if (m > 1) {
                    fprintf(stderr, "'%s' is not unique\n", part);
                } else {
                    wwzet_link(ww, &uuid, &res);
                }
            }
        }

        weewiki_close(ww);
        weewiki_clean(ww);
        free(line);
        free(ww);
        return 0;
    }

    return 1;
}
#+END_SRC
** export
Export. This will dump all the zet pairs as list of
tab-separated values to stdout. The idea would then be that
this information could then be processed further by
some external program.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_export(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_export(int argc, char *argv[])
{
    weewiki_d *ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "SELECT time,UUID,value from wikizet;",
                       -1,
                       &stmt,
                       NULL);


    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *t = (const char *)sqlite3_column_text(stmt, 0);
        printf("%s\t%s\t%s\n",
               (t == NULL) ? "-" : t,
               sqlite3_column_text(stmt, 1),
               sqlite3_column_text(stmt, 2));
        rc = sqlite3_step(stmt);
    }

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return 0;
}
#+END_SRC
** import
Import. Imports a list of tab-separated pairs into the zet
table.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_import(int argc, char *argv[]);
#+END_SRC

This import is very generalized, and will parse any
3-column TSV file without validation. It is assumed that
the input comes from a previous export.

#+NAME: funcs
#+BEGIN_SRC c
void import_line(weewiki_d *ww, const char *line, int sz)
{
    int pos;
    int i;
    const char *val[3];
    int vlen[3];
    int count;


    sz--; /* chomp line break */

    for (i = 0; i < 3; i++) {
        val[i] = NULL;
        vlen[i] = 0;
    }

    pos = 0;
    val[pos] = &line[0];
    count = 1;

    for (i = 0; i < sz; i++) {
        if (line[i] == '\t') {
            vlen[pos] = count - 1;
            val[pos + 1] = &line[i + 1];
            pos++;
            count = 0;
            if (pos >= 3) break;
        }
        count++;
    }

    /* wrap-up, address last count, minus linebreak */
    vlen[2] = count - 1;

    /* set timestamp to NULL if input is '-' */

    if (*val[0] == '-') {
        val[0] = NULL;
        vlen[0] = 1;
    }

    wwzet_insert(ww,
                 val[0], vlen[0],
                 val[1], vlen[1],
                 val[2], vlen[2]);
}

static int import_values(weewiki_d *ww)
{
    FILE *fp;
    sqlite3 *db;
    int err;
    char *buf;
    int sz;
    char c;

    fp = stdin;

    err = 0;

    db = weewiki_db(ww);
    sqlite3_exec(db, "BEGIN;\n", NULL, NULL, NULL);
    buf = calloc(1, 1024);
    sz = 0;

    while (1) {
        c = fgetc(fp);
        if (feof(fp)) break;
        buf[sz] = c;
        sz++;

        if (sz == 1023) {
            fprintf(stderr, "import buffer size too small\n");
            err = 1;
            goto clean;
        }

        if (c == '\n') {
            import_line(ww, buf, sz);
            sz = 0;
        }
    }

    sqlite3_exec(db, "COMMIT;\n", NULL, NULL, NULL);

    clean:
        free(buf);
        return err;
}

static int p_import(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    rc = import_values(ww);

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** rebuild
=rebuild= is similar to =import=, except that the operation
replaces the existing contents in the zet.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_rebuild(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_rebuild(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    sqlite3_exec(weewiki_db(ww),
                 "DELETE FROM wikizet WHERE 1;\n",
                 NULL, NULL, NULL);

    rc = import_values(ww);

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** info
Gets information on a particular zet item. A partial
UUID value can be provided.
** link
Link. Link item A to item B. A new zet pair will be made
with the A UUID value and the B reference. A and B can be
partial UUID values.
** search
Performs full-text search on the zet table.
** lookup
given a partial UUID, try to find the full matching
UUID. If more than one is found. return an error.
