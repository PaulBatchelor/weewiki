#+TITLE: zet
* Overview
Zet is a simple zettelkasten interface implemented in
weewiki.

Compared to the wiki, zet is more granular. Instead of
hypertext documents connected by links, you have things
connected to things. It is encouraged that information
be more atomic and bite-sized.

The zet will occupy a new SQLite table called "wikizet".
Like the main wiki, it too will have a key/value schema.
The difference in this case is that keys will not be unique.
This allows one key to point to multiple things.

A key is expected to be a uuid following the uuid4 specs.
This is generated courtesy of the uuid4 library by rxi. the
values are strings that can mean any number of things based
on the first character:

a "#" indicates that reference to another uuid. this is how
connections are made.

a "/" inidicates the start of a file such as /foo/bar.txt.
The intent of this is to use it with sqlar as a way to
reference and link files into weewiki.

a "!" indicates a reference to a wiki page. This follows
the adopted convention I've been using to reference wiki
pages in my twtxt messages.

a ">" explicitely indicates a string value.

values in the zet table optionally include a timestamp
value. This allows the zet to be used as a logging and
microblogging interface along the lines of twtxt.
* Tangled Files
=zet.c= and =zet.h= are the generated files.

#+NAME: zet.c
#+BEGIN_SRC c :tangle zet.c
#include <stdio.h>
#include <sqlite3.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include "uuid4/uuid4.h"
#include "weewiki.h"
#include "zet.h"
#include "linenoise/linenoise.h"
<<static_funcdefs>>
<<funcs>>
#+END_SRC

#+NAME: zet.h
#+BEGIN_SRC c :tangle zet.h
#ifndef ZET_H
#define ZET_H
<<typedefs>>
<<funcdefs>>
<<structs>>
#endif
#+END_SRC
* Low Level Operations
** UUIDs
A universally unique identifer (UUID) is used to label
every item in the zet. The UUIDs are generated courtesy
of the =uuid4= library by =rxi=, included inside of
the weewiki project.
*** UUID struct
A full UUID contained inside of a struct called
=wwzet_uuid=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wwzet_uuid wwzet_uuid;
#+END_SRC

This UUID contains a char of 37 bytes:
36 for the UUID (including dashes) plus the null terminator.

#+NAME: structs
#+BEGIN_SRC c
struct wwzet_uuid {
    char str[37];
};
#+END_SRC
*** (re)-initializing a UUID
The UUID is initialized with the function
=wwzet_uuid_init=. This will set the UUID to be
=00000000-0000-4000-8000-000000000000=, a valid
but zeroed UUID4.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_uuid_init(wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_uuid_init(wwzet_uuid *uuid)
{
    int i;
    static const char *zero =
        "00000000-0000-4000-8000-000000000000";

    for (i = 0; i < 36; i++) uuid->str[i] = zero[i];
    uuid->str[36] = 0;
}
#+END_SRC
*** Initializing the uuid4 RNG
Before generating a new UUID, the RNG must be
initialized with =wwzet_uuid_rng_init=.

This makes a call to =uuid4_init=.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_uuid_rng_init(void);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_uuid_rng_init(void)
{
    uuid4_init();
}
#+END_SRC
*** UUID generation
Create a new UUID with =wwzet_uuid_generate=. This uses
the uuid version 4 protocol, which means it is randomly
generated. This assumes the RNG has been initialized
already.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_uuid_generate(wwzet_uuid *uuid);
#+END_SRC

This function calls =uuid4_generate= under the hood, and
then stores the output to the =wwzet_uuid= variable
=uuid=.

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_uuid_generate(wwzet_uuid *uuid)
{
    uuid4_generate(uuid->str);
}
#+END_SRC
*** UUID expansion/validation
=wwzet_uuid_expand= will check if a partial UUID exists in
the zettelkasten table, and expand to full UUID value.
The partial value is provided as a null-terminated C string.

The number of matches is returned. Anything not equal to
1 is considered an error.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_uuid_expand(weewiki_d *ww,
                      const char *partial,
                      int sz,
                      wwzet_uuid *uuid);
#+END_SRC

The following SQLite3 statement is used:

#+BEGIN_SRC sqlite
SELECT UUID, COUNT(DISTINCT UUID) from wikizet where UUID LIKE(?1);
#+END_SRC

Where "?1" is the partial match.

This query will return a single row with the first found
wikizet, and the number of matches.

Actions will only happen when there is exactly 1 match.
This involves copying over the UUID value into the
variable.

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_uuid_expand(weewiki_d *ww,
                      const char *partial,
                      int sz,
                      wwzet_uuid *uuid)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    char *matchstr;
    int nmatches;

    matchstr = calloc(1, sz + 2);

    strcpy(matchstr, partial);
    matchstr[sz] = '%';

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "SELECT UUID, COUNT(DISTINCT UUID) FROM wikizet "
                       "WHERE UUID LIKE(?1);",
                       -1, &stmt, NULL);

    sqlite3_bind_text(stmt, 1, matchstr, sz + 1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        free(matchstr);
        sqlite3_finalize(stmt);
        return -1;
    }

    nmatches = sqlite3_column_int(stmt, 1);

    if (nmatches == 1) {
        int i;
        const char *str;
        str = (const char *)sqlite3_column_text(stmt, 0);

        for (i = 0; i < 36; i++) uuid->str[i] = str[i];
    }

    free(matchstr);
    sqlite3_finalize(stmt);
    return nmatches;
}
#+END_SRC
*** Get UUID from value
=wwzet_uuid_fromval=.

Given a value (presumably, a group), return the UUID.
non-zero value is an error.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_uuid_fromval(weewiki_d *ww,
                       const char *val,
                       int sz,
                       wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_uuid_fromval(weewiki_d *ww,
                       const char *val,
                       int sz,
                       wwzet_uuid *uuid)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int err;

    db = weewiki_db(ww);
    err = 0;

    sqlite3_prepare_v2(db,
                       "SELECT UUID FROM wikizet "
                       "WHERE value LIKE ?1;", -1,
                       &stmt, NULL);

    sqlite3_bind_text(stmt, 1, val, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        err = 1;
    } else {
        int i;
        const char *id;

        wwzet_uuid_init(uuid);
        id = (const char *)sqlite3_column_text(stmt, 0);

        for (i = 0; i < 36; i++) {
            uuid->str[i] = id[i];
        }
    }

    sqlite3_finalize(stmt);

    return err;
}
#+END_SRC
*** Get UUID from ergo ID
=wwzet_uuid_fromergo= will expand a UUID expressed in
ergo format.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_uuid_fromergo(weewiki_d *ww,
                        const char *ergo,
                        int sz,
                        wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_uuid_fromergo(weewiki_d *ww,
                        const char *ergo,
                        int sz,
                        wwzet_uuid *uuid)
{
    char *partial;
    int rc;

    partial = calloc(1, sz + 1);

    wwzet_ergo_to_hex(ergo, sz, partial);

    rc = wwzet_uuid_expand(ww, partial, sz, uuid);

    free(partial);

    return rc;
}
#+END_SRC
*** Resolve a UUID
=wwzet_uuid_resolve= smartly resolves a UUID from
a string value. Will return a non-zero value on error.

The default behavior of resolve is to expand a partial UUID.
However, certain prefixes in the string will cause it to be
treated as a value lookup.

Currently, valid prefixes are =@= (groups), =!= (pages),
and =/= (=crate= filepaths). Message (=>=) and
addresses (=#=) are to be ignored because they have less
of a chance of being unique.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_uuid_resolve(weewiki_d *ww,
                       const char *val,
                       int sz,
                       wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_uuid_resolve(weewiki_d *ww,
                       const char *val,
                       int sz,
                       wwzet_uuid *uuid)
{
    int err;
    int rc;
    int special_prefix;
    err = 0;

    wwzet_uuid_init(uuid);

    special_prefix =
        val[0] == '@' ||
        val[0] == '!' ||
        val[0] == '/';

    if (special_prefix) {
        rc = wwzet_uuid_fromval(ww, val, sz, uuid);
        if (rc) err = 1;
    } else if (val[0] == 'g') {
        rc = wwzet_uuid_fromergo(ww, val + 1, sz - 1, uuid);
        if (rc != 1) err = 1;
    } else {
        rc = wwzet_uuid_expand(ww, val, sz, uuid);
        if (rc != 1) err = 1;
    }

    return err;
}
#+END_SRC
** Create Zet Entry
=wwzet_entry= creates a generic zet entry given a message
and timestamps it based on the current system time.

If =uuid= is not NULL, the generated UUID is saved here.
It is assumed the uuid RNG is initialized already before
calling this function.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_entry(weewiki_d *ww,
                const char *msg,
                int sz,
                wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_entry(weewiki_d *ww,
                const char *msg,
                int sz,
                wwzet_uuid *uuid)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    wwzet_uuid id;
    int rc;

    wwzet_uuid_init(&id);
    db = weewiki_db(ww);
    wwzet_uuid_generate(&id);

    sqlite3_prepare_v2(db,
                       "INSERT INTO "
                       "wikizet(time, UUID, value)"
                       "VALUES(datetime(), ?1, ?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, id.str, -1, NULL);
    sqlite3_bind_text(stmt, 2, msg, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        return 1;
    }

    if (uuid != NULL) *uuid = id;

    sqlite3_finalize(stmt);
    return 0;
}
#+END_SRC
** Create Zet Entry (With Symbol)
The function =wwzet_entry_withsymbol= wraps around
=wwzet_entry= to create a new timestamped entry and
prepends it with a single-character symbol.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_entry_withsymbol(weewiki_d *ww,
                           char c,
                           const char *msg,
                           int sz,
                           wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_entry_withsymbol(weewiki_d *ww,
                           char c,
                           const char *msg,
                           int sz,
                           wwzet_uuid *uuid)
{
    char *val;
    int rc;

    val = malloc(sz + 2);
    val[0] = c;

    strncpy(&val[1], msg, sz);

    val[sz + 1] = '\0';

    rc = wwzet_entry(ww, val, sz + 1, uuid);

    free(val);
    return rc;
}
#+END_SRC
** Insert an Entry
The function =wwzet_insert= will perform a low-level
insert command into the wikizet table. The timestamp,
uuid, and value should already be generated or known.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_insert(weewiki_d *ww,
                  const char *timestamp, int tlen,
                  const char *uuid, int ulen,
                  const char *value, int vlen);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_insert(weewiki_d *ww,
                  const char *timestamp, int tlen,
                  const char *uuid, int ilen,
                  const char *value, int vlen)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "INSERT into wikizet(time,uuid,value) "
                       "VALUES(?1,?2,?3);",
                       -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, timestamp, tlen, NULL);
    sqlite3_bind_text(stmt, 2, uuid, ilen, NULL);
    sqlite3_bind_text(stmt, 3, value, vlen, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
    }

    sqlite3_finalize(stmt);
}
#+END_SRC
** Create Zet Message
The function =wwzet_message= will create a
timestamped entry with a message in the zet table
with a new UUID.

What is required is the main weewiki data, message, as well
as the message length. The resulting UUID will get placed in
the supplied UUID pointer if it is not NULL.

Be sure to open the database and initialize the UUID4 RNG
before calling this.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_message(weewiki_d *ww,
                  const char *msg,
                  int sz,
                  wwzet_uuid *uuid);
#+END_SRC

Under the hood, this will generate a UUID and create an
insert SQLite statement using the SQLite API.

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_message(weewiki_d *ww,
                  const char *msg,
                  int sz,
                  wwzet_uuid *uuid)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    wwzet_uuid id;
    int rc;
    char *val;

    val = malloc(sz + 2);

    val[0] = '>';

    strcpy(&val[1], msg);
    wwzet_uuid_init(&id);
    db = weewiki_db(ww);
    wwzet_uuid_generate(&id);

    sqlite3_prepare_v2(db,
                       "INSERT INTO "
                       "wikizet(time, UUID, value)"
                       "VALUES(datetime(), ?1, ?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, id.str, -1, NULL);
    sqlite3_bind_text(stmt, 2, val, sz + 1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        free(val);
        return 1;
    }

    if (uuid != NULL) *uuid = id;

    free(val);
    sqlite3_finalize(stmt);
    return 0;
}
#+END_SRC
** Create Zet Link
The function =wwzet_link= will link UUID A to
UUID B.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_link(weewiki_d *ww, wwzet_uuid *a, wwzet_uuid *b);
#+END_SRC

A link is created by creating a new entry using A's UUID,
and having the value be the UUID of B. A UUID is prepended
with a '#'.

#+NAME: funcs
#+BEGIN_SRC c
void wwzet_link(weewiki_d *ww, wwzet_uuid *a, wwzet_uuid *b)
{
    char *addr;

    addr = calloc(1, 38);
    addr[0] = '#';
    strcpy(&addr[1], b->str);
    wwzet_insert(ww, NULL, 0, a->str, 36, addr, 37);
    free(addr);
}
#+END_SRC
** Create Zet File
A file entry is created with =wwzet_file=.

An inserted file is not actually the file, but just
a file path, prepended with a forward slash =/=.
Presumably, this would link to an entry in the SQLar table
(which do not have leading slashes). Thus, an entry
=/test/foo.txt= would have a corresponding SQLar file
=test/foo.txt=.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_file(weewiki_d *ww,
               const char *filename,
               int sz,
               wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_file(weewiki_d *ww,
               const char *filename,
               int sz,
               wwzet_uuid *uuid)
{
    return wwzet_entry_withsymbol(ww, '/', filename, sz, uuid);
}
#+END_SRC
** Create Zet Group
A group entry is created with =wwzet_group=.

Groups are used with the crate interface, and are used
to link files to specific sqlar archives.

Groups are prefixed with '@'.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_group(weewiki_d *ww,
               const char *group,
               int sz,
               wwzet_uuid *uuid);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_group(weewiki_d *ww,
               const char *filename,
               int sz,
               wwzet_uuid *uuid)
{
    return wwzet_entry_withsymbol(ww, '@', filename, sz, uuid);
}
#+END_SRC
** Ergo IDs
Ergonomic IDs, or Ergo IDs are a way of of representing
UUIDs in a more typist-friendly QWERTY format. traditional
representations of hex values are replaced by easy to
access characters in the QWERTY format.

So. What are the easy characters?

The home row is easiest: asdfghjkl;

The top row comes next: qwertyuiop

The keys that do not require any extensions are the most
ergonomically efficient. These include:

home: asdfjkl;

top: qweruiop

The semi-colon ';' is a bit of an outlier. To limit things
to only the alphabet, one could use 'h', which is familiar
enough for vi-inclined individuals used to hjkl.

So that leaves us with:

home: asdfhjkl

top: qweruoip

treating the number system as left-to-right, home-to-top,
we get:

asdfhjklqweruiop

0123456789abcdef

Convert from a hex string to ergo ID with
=wwzet_hex_to_ergo=.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_hex_to_ergo(const char *hex, int sz, char *ergo);
#+END_SRC

Converting to this ergo-id format is a pretty
straightforward process. convert the ascii hex value to a
number and send it to a lookup table which is just an array.

#+NAME: funcs
#+BEGIN_SRC c
<<hexergo_lookup>>
void wwzet_hex_to_ergo(const char *hex, int sz, char *ergo)
{
    int i;

    for (i = 0; i < sz; i++) {
        int pos;

        pos = -1;
        if (hex[i] >= '0' && hex[i] <= '9') {
            pos = hex[i] - '0';
        } else if (hex[i] >= 'a' && hex[i] <= 'f') {
            pos = (hex[i] - 'a') + 10;
        }

        if (pos >= 0) {
            ergo[i] = hexergo[pos];
        } else {
            ergo[i] = hex[i];
        }
    }

    ergo[sz] = '\0';
}
#+END_SRC

#+NAME: hexergo_lookup
#+BEGIN_SRC c
static const char *hexergo = "asdfhjklqweruiop";
#+END_SRC

Convert from ergo to hex string with =wwzet_ergo_to_hex=.

#+NAME: funcdefs
#+BEGIN_SRC c
void wwzet_ergo_to_hex(const char *ergo, int sz, char *hex);
#+END_SRC

Converting from the ergo-id to the hex value is a little
less straightforward.

#+NAME: funcs
#+BEGIN_SRC c
<<ergohex_lookup>>
void wwzet_ergo_to_hex(const char *ergo, int sz, char *hex)
{
    int i;
    for (i = 0; i < sz; i++) {
        if (ergo[i] >= 'a' && ergo[i] <= 'w') {
            int pos = ergo[i] - 'a';
            hex[i] = ergohex[pos];
        } else {
            hex[i] = ergo[i];
        }
    }
}
#+END_SRC

A lookup table will be produced by sorting the values in
ascii order:

adefhijklopqrsuw

with the corresponding hex values:

02a34d567ef8b1c9

With '?' as filler:

a??def?hijkl??opqrs?u?w

or

0??2a3?4d567??ef8b1?c?9


or ascii values 97-112. which means a lookup table of size
23 with empty values.

#+NAME: ergohex_lookup
#+BEGIN_SRC c
static const char *ergohex = "0??2a3?4d567??ef8b1?c?9";
#+END_SRC
** Check if entry exists
Usually for things like groups, you want to ensure
that it is unique. This function will query a value
with a symbol and report of it exists already.

=wwzet_entry_exists= will check if a string value
=val= of size =sz= exists with a prepended symbol =sym=.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_entry_exists(weewiki_d *ww,
                       char sym,
                       const char *val,
                       int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_entry_exists(weewiki_d *ww,
                       char sym,
                       const char *val,
                       int sz)
{
    int exists;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    exists = 0;

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "SELECT EXISTS( "
                       "SELECT value FROM wikizet WHERE "
                       "value IS ?1 || ?2);",
                       -1, &stmt, NULL);

    sqlite3_bind_text(stmt, 1, &sym, 1, NULL);
    sqlite3_bind_text(stmt, 2, val, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr, "SQLite: '%s'\n", sqlite3_errmsg(db));
        exists = -1;
    } else {
        exists = sqlite3_column_int(stmt, 0);
    }

    sqlite3_finalize(stmt);

    return exists;
}
#+END_SRC
* Variables
** Variables Overview
A variable type in zet is a thing that can be chaned over
time. The format is "$key:value". The message starts with
"$" to inidicate the type flag. The variable name "key" is
inbetween the "$" and the ":". The remaining part of the
message is the value, which can be treated like another zet
value.
** Create a New Variable
A variable must be explicitely created before it can be
used. This is done to minimize typo-related errors. (At the
time of writing, zet doesn't isn't great at removing or
editing commands). =wwzet_var_new= will create a new
variable =var= and tie it to a item with UUID =id=. The
value will be set to be empty.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_var_new(weewiki_d *ww,
                  wwzet_uuid *id,
                  const char *var,
                  int sz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_var_new(weewiki_d *ww,
                  wwzet_uuid *id,
                  const char *var,
                  int sz)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int err;
    db = weewiki_db(ww);

    err = 0;

    sqlite3_prepare_v2(db,
    "INSERT INTO wikizet(time, UUID, value) "
    "SELECT datetime(), ?1, '$' || ?2 || ':' "
    "WHERE NOT EXISTS (SELECT 1 from wikizet WHERE "
    "UUID LIKE ?1 AND "
    "VALUE like '$' || ?2 || ':%');",
    -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, id->str, -1, NULL);
    sqlite3_bind_text(stmt, 2, var, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        err = 1;
    }

    sqlite3_finalize(stmt);

    return err;
}
#+END_SRC
** Setting a Variable to be a Link
A variable can be set to link to another UUID with
=wwzet_var_link=.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_var_link(weewiki_d *ww,
                   wwzet_uuid *id,
                   const char *var, int sz,
                   wwzet_uuid *ref);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_var_link(weewiki_d *ww,
                   wwzet_uuid *id,
                   const char *var, int sz,
                   wwzet_uuid *ref)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int err;
    db = weewiki_db(ww);

    err = 0;

    sqlite3_prepare_v2(db,
    "UPDATE wikizet "
    "SET time = datetime(), "
    "value = '$' || ?1 || ':#' || ?2"
    "WHERE (UUID is ?3 AND "
    "value LIKE '$' || ?1 || ':%');",
    -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, var, sz, NULL);
    sqlite3_bind_text(stmt, 2, ref->str, -1, NULL);
    sqlite3_bind_text(stmt, 3, id->str, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        err = 1;
    }

    if (sqlite3_changes(db) == 0) {
        err = 1;
    }

    sqlite3_finalize(stmt);

    return err;
}
#+END_SRC
** Setting a Variable to be a Message
A variable can be set to be a message with
=wwzet_var_message=.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_var_message(weewiki_d *ww,
                      wwzet_uuid *id,
                      const char *var, int vsz,
                      const char *msg, int msz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_var_message(weewiki_d *ww,
                      wwzet_uuid *id,
                      const char *var, int vsz,
                      const char *msg, int msz)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int err;
    db = weewiki_db(ww);

    err = 0;

    sqlite3_prepare_v2(db,
    "UPDATE wikizet "
    "SET time = datetime(), "
    "value = '$' || ?1 || ':>' || ?2"
    "WHERE (UUID is ?3 AND "
    "value LIKE '$' || ?1 || ':%');",
    -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, var, vsz, NULL);
    sqlite3_bind_text(stmt, 2, msg, msz, NULL);
    sqlite3_bind_text(stmt, 3, id->str, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        err = 1;
    }

    if (sqlite3_changes(db) == 0) {
        err = 1;
    }

    sqlite3_finalize(stmt);

    return err;
}
#+END_SRC
** Touching A Variable
=wwzet_var_touch= will touch a variable in a UUID, updating
the timestamp to the present. Touch gets its name from the
Unix command which is used in a similar way.

If the variable can't be found or another error happens,
a non-zero value will be returned.

#+NAME: funcdefs
#+BEGIN_SRC c
int wwzet_var_touch(weewiki_d *ww,
                    wwzet_uuid *id,
                    const char *var, int vsz);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int wwzet_var_touch(weewiki_d *ww,
                    wwzet_uuid *id,
                    const char *var, int vsz)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int err;
    db = weewiki_db(ww);

    err = 0;

    sqlite3_prepare_v2(db,
    "UPDATE wikizet "
    "SET time = datetime() "
    "WHERE (UUID is ?2 AND "
    "value LIKE '$' || ?1 || ':%');",
    -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, var, vsz, NULL);
    sqlite3_bind_text(stmt, 2, id->str, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        err = 1;
    }

    if (sqlite3_changes(db) == 0) {
        err = 1;
    }

    sqlite3_finalize(stmt);

    return err;
}
#+END_SRC
** Command Line Interface
Here are some command line operations, all under the
subcommand "var"
*** Top Level
All variable subcommands get here.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int zet_var(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int zet_var(weewiki_d *ww, int argc, char *argv[])
{
    argc--;
    argv++;

    if (argc <= 0) {
        fprintf(stderr, "Please enter a command.\n");
        return 1;
    }

    if (!strcmp(argv[0], "new")) {
        return p_varnew(ww, argc, argv);
    } else if (!strcmp(argv[0], "link")) {
        return p_varlink(ww, argc, argv);
    } else if (!strcmp(argv[0], "list")) {
        return p_varlist(ww, argc, argv);
    } else if (!strcmp(argv[0], "set")) {
        return p_varset(ww, argc, argv);
    } else if (!strcmp(argv[0], "touch")) {
        return p_vartouch(ww, argc, argv);
    } else if (!strcmp(argv[0], "get")) {
        return p_varget(ww, argc, argv);
    } else if (!strcmp(argv[0], "create")) {
        return p_varcreate(ww, argc, argv);
    } else {
        fprintf(stderr, "Could not find command '%s'\n", argv[0]);
    }
    return 1;
}
#+END_SRC
*** New
usage: new uuid name

creates a new variable called =name=. with a uuid =uuid=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_varnew(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_varnew(weewiki_d *ww, int argc, char *argv[])
{
    int rc;
    wwzet_uuid id;
    const char *idstr;
    const char *name;

    if (argc < 3) {
        fprintf(stderr, "Usage: new UUID name\n");
        return 1;
    }

    idstr = argv[1];
    name = argv[2];

    rc = wwzet_uuid_resolve(ww, idstr, strlen(idstr), &id);

    if (rc) {
        fprintf(stderr, "Could not resolve '%s'\n", idstr);
        return 1;
    }

    rc = wwzet_var_new(ww, &id, name, strlen(name));

    if (rc) {
        fprintf(stderr,
                "Issue with creating variable '%s'\n",
                name);
        return 1;
    }

    return 0;
}
#+END_SRC
*** Link
usage: link uuid name value

sets a variable to link with an existing item. =value= can
be a UUID, group, page, or anything else that the zet can
resolve.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_varlink(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_varlink(weewiki_d *ww, int argc, char *argv[])
{
    int rc;
    wwzet_uuid id;
    const char *idstr;
    const char *name;
    wwzet_uuid ref;
    const char *refstr;

    if (argc < 4) {
        fprintf(stderr, "Usage: link UUID name value\n");
        return 1;
    }

    idstr = argv[1];
    name = argv[2];
    refstr = argv[3];

    rc = wwzet_uuid_resolve(ww, idstr, strlen(idstr), &id);

    if (rc) {
        fprintf(stderr, "Could not resolve '%s'\n", idstr);
        return 1;
    }

    rc = wwzet_uuid_resolve(ww, refstr, strlen(refstr), &ref);

    if (rc) {
        fprintf(stderr, "Could not resolve '%s'\n", refstr);
        return 1;
    }

    rc = wwzet_var_link(ww, &id, name, strlen(name), &ref);

    if (rc) {
        fprintf(stderr,
                "Issue linking variable '%s' (does it exist?)\n",
                name);
        return 1;
    }

    return 0;
}
#+END_SRC
*** List
usage: list name item

List UUIDs with the variable =name= and item name =item=.
For example, running =list state @TODO= would list all
UUIDs with the variable state pointing to the TODO group.

These will be ordered by timestamp in ascending order.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_varlist(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_varlist(weewiki_d *ww, int argc, char *argv[])
{
    int rc;
    const char *name;
    wwzet_uuid ref;
    const char *refstr;
    sqlite3 *db;
    sqlite3_stmt *stmt;

    if (argc < 3) {
        fprintf(stderr, "Usage: list name value\n");
        return 1;
    }

    name = argv[1];
    refstr = argv[2];

    rc = wwzet_uuid_resolve(ww, refstr, strlen(refstr), &ref);

    if (rc) {
        fprintf(stderr, "Could not resolve '%s'\n", refstr);
        return 1;
    }

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
    "SELECT datetime(time, 'localtime'), UUID, value FROM wikizet "
    "WHERE UUID in (SELECT UUID from wikizet "
    "WHERE VALUE LIKE '$' || ?1 || ':#' || ?2 "
    "ORDER by strftime(time) ASC);", -1, &stmt, NULL);

    sqlite3_bind_text(stmt, 1, name, -1, NULL);
    sqlite3_bind_text(stmt, 2, ref.str, -1, NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *t, *u, *v;

        t = (const char *)sqlite3_column_text(stmt, 0);
        u = (const char *)sqlite3_column_text(stmt, 1);
        v = (const char *)sqlite3_column_text(stmt, 2);

        printf("%s\t%s\t%s\n", (t == NULL ? "-" : t), u, v);

        rc = sqlite3_step(stmt);
    }


    sqlite3_finalize(stmt);
    return 0;
}
#+END_SRC
*** Set
usage: set uuid name value

Sets the variable =name= to be =value=. Note that this
implicitely sets the value type to be a message.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_varset(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_varset(weewiki_d *ww, int argc, char *argv[])
{
    int rc;
    wwzet_uuid id;
    const char *idstr;
    const char *name;
    const char *msg;
    char *line;

    line = NULL;

    if (argc < 3) {
        fprintf(stderr, "Usage: set UUID name value\n");
        return 1;
    }

    idstr = argv[1];
    name = argv[2];

    if (argc == 4) {
        msg = argv[3];
    } else {
        line = linenoise("set: ");
        msg = line;
    }

    rc = wwzet_uuid_resolve(ww, idstr, strlen(idstr), &id);

    if (rc) {
        fprintf(stderr, "Could not resolve '%s'\n", idstr);
        return 1;
    }

    rc = wwzet_var_message(ww, &id,
                           name, strlen(name),
                           msg, strlen(msg));

    if (rc) {
        fprintf(stderr,
                "Issue setting variable '%s' (does it exist?)\n",
                name);
        return 1;
    }


    if (line != NULL) free(line);

    return 0;
}
#+END_SRC
*** Get
usage: get uuid name

gets the variable =name= associated with =uuid=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_varget(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_varget(weewiki_d *ww, int argc, char *argv[])
{
    int rc;
    wwzet_uuid id;
    const char *idstr;
    const char *name;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int e;

    e = 0;

    if (argc < 2) {
        fprintf(stderr, "Usage: get UUID name\n");
        return 1;
    }

    idstr = argv[1];
    name = argv[2];

    rc = wwzet_uuid_resolve(ww, idstr, strlen(idstr), &id);

    if (rc) {
        fprintf(stderr, "Could not resolve '%s'\n", idstr);
        return 1;
    }


    db = weewiki_db(ww);

    rc = sqlite3_prepare_v2(db,
                       "SELECT substr(value, length(?2) + 3) FROM wikizet "
                       "WHERE UUID is ?1 "
                       "AND value LIKE '$'||?2||':%' "
                       "LIMIT 1 "
                       ";", -1, &stmt, NULL);

    sqlite3_bind_text(stmt, 1, id.str, -1, NULL);
    sqlite3_bind_text(stmt, 2, name, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr, "Could not find variable '%s'\n", name);
        e = 1;
    } else {
        fwrite(sqlite3_column_text(stmt, 0), 1,
               sqlite3_column_bytes(stmt, 0), stdout);
        fflush(stdout);
    }

    sqlite3_finalize(stmt);

    return e;
}
#+END_SRC
*** Touch
usage: touch uuid varname

Update the timestamp of a variable to the present.
Useful in programs like zetdo where lists are ordered
chronologically.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_vartouch(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_vartouch(weewiki_d *ww, int argc, char *argv[])
{
    int rc;
    wwzet_uuid id;
    const char *idstr;
    const char *name;

    if (argc < 3) {
        fprintf(stderr, "Usage: touch UUID varname\n");
        return 1;
    }

    idstr = argv[1];
    name = argv[2];

    rc = wwzet_uuid_resolve(ww, idstr, strlen(idstr), &id);

    if (rc) {
        fprintf(stderr, "Could not resolve '%s'\n", idstr);
        return 1;
    }

    rc = wwzet_var_touch(ww, &id, name, strlen(name));

    if (rc) {
        fprintf(stderr,
                "Issue setting variable '%s' (does it exist?)\n",
                name);
        return 1;
    }

    return 0;
}
#+END_SRC
*** Create
usage: create name

The =create= command creates a brand new zet entry with UUID
with a variable. This is similar to =new=, except that a
UUID doesn't need to exist.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_varcreate(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_varcreate(weewiki_d *ww, int argc, char *argv[])
{
    int rc;
    wwzet_uuid id;
    const char *name;

    if (argc < 2) {
        fprintf(stderr, "Usage: create name\n");
        return 1;
    }

    wwzet_uuid_rng_init();
    wwzet_uuid_init(&id);
    wwzet_uuid_generate(&id);

    name = argv[1];

    rc = wwzet_var_new(ww, &id, name, strlen(name));

    if (rc) {
        fprintf(stderr,
                "Issue with creating variable '%s'\n",
                name);
        return 1;
    }

    printf("%s\n", id.str);

    return 0;
}
#+END_SRC
* Command Line Operations
** top-level processor
The entry point for the top-level CLI is done with
=ww_zet=.

#+NAME: funcdefs
#+BEGIN_SRC c
int ww_zet(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int ww_zet(int argc, char *argv[])
{
    if (argc <= 1) {
        fprintf(stderr, "Zet: supply a command\n");
        return 1;
    }

    argv++; argc--;

    if (!strcmp(argv[0], "say")) {
        return p_say(argc, argv);
    } else if (!strcmp(argv[0], "export")) {
        return p_export(argc, argv);
    } else if (!strcmp(argv[0], "import")) {
        return p_import(argc, argv);
    } else if (!strcmp(argv[0], "rebuild")) {
        return p_rebuild(argc, argv);
    } else if (!strcmp(argv[0], "groups")) {
        return p_groups(argc, argv);
    } else if (!strcmp(argv[0], "link")) {
        return p_link(argc, argv);
    } else if (!strcmp(argv[0], "search")) {
        return p_search(argc, argv);
    } else if (!strcmp(argv[0], "mkgroup")) {
        return p_mkgroup(argc, argv);
    } else if (!strcmp(argv[0], "pages")) {
        return p_pages(argc, argv);
    } else if (!strcmp(argv[0], "mkpage")) {
        return p_mkpage(argc, argv);
    } else if (!strcmp(argv[0], "resolve")) {
        return p_resolve(argc, argv);
    } else if (!strcmp(argv[0], "shuffle")) {
        return p_shuffle(argc, argv);
    } else if (!strcmp(argv[0], "var")) {
        return p_var(argc, argv);
    } else if (!strcmp(argv[0], "rawsay")) {
        return p_rawsay(argc, argv);
    } else if (!strcmp(argv[0], "tags")) {
        return p_tags(argc, argv);
    } else if (!strcmp(argv[0], "entry")) {
        return p_entry(argc, argv);
    } else if (!strcmp(argv[0], "ergoify")) {
        return p_ergoify(argc, argv);
    } else if (!strcmp(argv[0], "uuid")) {
        return p_uuid(argc, argv);
    } else if (!strcmp(argv[0], "ergo")) {
        return p_ergo(argc, argv);
    } else if (!strcmp(argv[0], "mkfile")) {
        return p_mkfile(argc, argv);
    } else if (!strcmp(argv[0], "linked")) {
        return p_linked(argc, argv);
    } else if (!strcmp(argv[0], "tie")) {
        return p_tie(argc, argv);
    } else if (!strcmp(argv[0], "belongs")) {
        return p_belongs(argc, argv);
    } else {
        fprintf(stderr, "Could not find command '%s'\n", argv[0]);
    }

    return 1;
}
#+END_SRC
** say
creates a new UUID with a timestamped message. Any arguments
provided are expected to be partial UUIDs of pre-existing
zet items.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_say(int argc, char *argv[]);
#+END_SRC

#+NAME: do_say
#+BEGIN_SRC c
static int do_say(int argc, char *argv[], int use_linenoise)
{
    char *line;

    if (use_linenoise) line = linenoise("say: ");
    else {
        line = argv[1];
        argc--;
        argv++;
    }

    if (line != NULL) {
        weewiki_d *ww;
        wwzet_uuid uuid;
        int rc;

        ww = malloc(weewiki_sizeof());
        weewiki_init(ww);
        weewiki_open(ww, weewiki_dbname_get());

        wwzet_uuid_rng_init();
        wwzet_uuid_init(&uuid);
        rc = wwzet_message(ww, line, strlen(line), &uuid);

        if (!rc) printf("%s\n", uuid.str);

        if (argc > 1) {
            wwzet_uuid res;
            int p;

            for (p = 1; p < argc; p++) {
                const char *part;
                part = argv[p];

                wwzet_uuid_init(&res);
                rc = wwzet_uuid_resolve(ww,
                                        part,
                                        strlen(part),
                                        &res);
                if (rc) {
                    fprintf(stderr, "Could not resolve '%s'\n", part);
                } else {
                    wwzet_link(ww, &uuid, &res);
                }
            }
        }

        weewiki_close(ww);
        weewiki_clean(ww);
        if (use_linenoise) free(line);
        free(ww);
        return 0;
    }

    return 1;
}
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
<<do_say>>
static int p_say(int argc, char *argv[])
{
    return do_say(argc, argv, 1);
}
#+END_SRC

** rawsay
like say, but read the message as the first argument.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_rawsay(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_rawsay(int argc, char *argv[])
{
    return do_say(argc, argv, 0);
}
#+END_SRC
** export
Export. This will dump all the zet pairs as list of
tab-separated values to stdout. The idea would then be that
this information could then be processed further by
some external program.
*** Top level Function
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_export(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
<<export_group>>
<<export_all>>
static int p_export(int argc, char *argv[])
{
    if (argc == 1) return export_all();
    return export_group(argv[1]);
}
#+END_SRC
*** Export All
When no extra arguments are given, all of the zet is
exported.

#+NAME: export_all
#+BEGIN_SRC c
static int export_all(void)
{
    weewiki_d *ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "SELECT time,UUID,value from wikizet;",
                       -1,
                       &stmt,
                       NULL);


    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *t = (const char *)sqlite3_column_text(stmt, 0);
        printf("%s\t%s\t%s\n",
               (t == NULL) ? "-" : t,
               sqlite3_column_text(stmt, 1),
               sqlite3_column_text(stmt, 2));
        rc = sqlite3_step(stmt);
    }

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return 0;
}
#+END_SRC
*** Group Export
For larger zettelkastens (such as managing a sample
library via the crate interface), it makes more sense to
export things by group rather than all at once. A group can
be exported by supplying it as an optional argument on the
commandline. Any zet items linked to that group will be
exported, including the group entry itself.

To begin group export, the UUID of the groupname must be
found via SQL query. This entry will be the first thing
to be exported.

In order to look for a groupname, an =@= must be prepended
to the beginning of the string.

#+NAME: find_group_uuid
#+BEGIN_SRC c
{
    sqlite3_stmt *stmt;
    char *g;
    const char *idstr;
    const char *t;
    const char *v;
    int rc;
    int i;

    g = calloc(1, strlen(group) + 2);

    g[0] = '@';

    strcpy(&g[1], group);

    sqlite3_prepare_v2(db,
                       "SELECT uuid, time, value FROM wikizet "
                       "WHERE value LIKE ?1;", -1,
                       &stmt, NULL);
    sqlite3_bind_text(stmt, 1, g, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr, "Could not find group %s\n", group);
        free(g);
        sqlite3_finalize(stmt);
        err = 1;
        goto cleanup;
    }

    wwzet_uuid_init(&groupid);

    idstr = (const char *)sqlite3_column_text(stmt, 0);
    t = (const char *)sqlite3_column_text(stmt, 1);
    v = (const char *)sqlite3_column_text(stmt, 2);

    printf("%s\t%s\t%s\n", t, idstr, v);

    for (i = 0; i < 36; i++) {
        groupid.str[i] = idstr[i];
    }

    sqlite3_finalize(stmt);
    free(g);
}
#+END_SRC

From there, another query happens where every reference to
that UUID is found. This requires converting the UUID to an
address, done by prepending a =#= to it.

Update: this query-within-a-query ended up being massively
slow, so I figured out how to do the same thing in a
subquery.

#+NAME: find_references
#+BEGIN_SRC c
{
    char *ref;
    sqlite3_stmt *stmt;
    int rc;
    int i;

    ref = calloc(1, 38);

    ref[0] = '#';

    for (i = 0; i < 36; i++) {
        ref[i + 1] = groupid.str[i];
    }

    sqlite3_prepare_v2(db,
                       "SELECT time, UUID, value FROM wikizet "
                       "WHERE UUID IN ("
                       "SELECT UUID "
                       "FROM wikizet "
                       "WHERE value LIKE ?1);", -1,
                       &stmt, NULL);

    sqlite3_bind_text(stmt, 1, ref, -1, NULL);
    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *t, *v, *id;
        t = (const char *)sqlite3_column_text(stmt, 0);
        id = (const char *)sqlite3_column_text(stmt, 1);
        v = (const char *)sqlite3_column_text(stmt, 2);
        printf("%s\t%s\t%s\n",
               (t == NULL) ? "-" : t,
               id,
               v);
        rc = sqlite3_step(stmt);
    }

    sqlite3_finalize(stmt);
    free(ref);
}
#+END_SRC

For every row that shows up, query item that has that UUID,
and export. Included in this should be the link to the
group, so this link is implicitly exported along with
everything else.

#+NAME: export_group
#+BEGIN_SRC c
static int export_group(const char *group)
{
    wwzet_uuid groupid;
    weewiki_d *ww;
    sqlite3 *db;
    int err;

    err = 0;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);

    <<find_group_uuid>>
    <<find_references>>

    cleanup:
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return err;
}
#+END_SRC
** import
Import. Imports a list of tab-separated pairs into the zet
table.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_import(int argc, char *argv[]);
#+END_SRC

This import is very generalized, and will parse any
3-column TSV file without validation. It is assumed that
the input comes from a previous export.

#+NAME: funcs
#+BEGIN_SRC c
void import_line(weewiki_d *ww, const char *line, int sz)
{
    int pos;
    int i;
    const char *val[3];
    int vlen[3];
    int count;


    sz--; /* chomp line break */

    for (i = 0; i < 3; i++) {
        val[i] = NULL;
        vlen[i] = 0;
    }

    pos = 0;
    val[pos] = &line[0];
    count = 1;

    for (i = 0; i < sz; i++) {
        if (line[i] == '\t') {
            vlen[pos] = count - 1;
            val[pos + 1] = &line[i + 1];
            pos++;
            count = 0;
            if (pos >= 3) break;
        }
        count++;
    }

    /* wrap-up, address last count, minus linebreak */
    vlen[2] = count - 1;

    /* set timestamp to NULL if input is '-' */

    if (*val[0] == '-') {
        val[0] = NULL;
        vlen[0] = 1;
    }

    wwzet_insert(ww,
                 val[0], vlen[0],
                 val[1], vlen[1],
                 val[2], vlen[2]);
}

static int import_values(weewiki_d *ww)
{
    FILE *fp;
    sqlite3 *db;
    int err;
    char *buf;
    int sz;
    char c;
    int bufsz;

    fp = stdin;

    err = 0;

    db = weewiki_db(ww);
    sqlite3_exec(db, "BEGIN;\n", NULL, NULL, NULL);
    bufsz = 1024;
    buf = calloc(1, bufsz);
    sz = 0;

    while (1) {
        c = fgetc(fp);
        if (feof(fp)) break;
        buf[sz] = c;
        sz++;

        if (sz == (bufsz - 1)) {
            fprintf(stderr,
                "Warning: long line. Reallocating.\n");
            bufsz *= 2;
            buf = realloc(buf, bufsz);
        }

        if (c == '\n') {
            import_line(ww, buf, sz);
            sz = 0;
        }
    }

    sqlite3_exec(db, "COMMIT;\n", NULL, NULL, NULL);

    free(buf);
    return err;
}

static int p_import(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    rc = import_values(ww);

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** rebuild
=rebuild= is similar to =import=, except that the operation
replaces the existing contents in the zet.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_rebuild(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_rebuild(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    sqlite3_exec(weewiki_db(ww),
                 "DELETE FROM wikizet WHERE 1;\n",
                 NULL, NULL, NULL);

    rc = import_values(ww);

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** link
Link. Link item A to item B. A new zet pair will be made
with the A UUID value and the B reference. A and B can be
partial UUID values.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_link(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_link(int argc, char *argv[])
{
    int err;
    weewiki_d *ww;
    wwzet_uuid a, b;
    int rc;

    err = 0;

    if (argc <= 2) {
        fprintf(stderr, "Usage: %s UUIDA UUIDB\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    rc = wwzet_uuid_resolve(ww, argv[1], strlen(argv[1]), &a);

    if (rc) {
        fprintf(stderr,
                "Could not resolve '%s'\n", argv[1]);
        err = 1;
        goto clean;
    }

    rc = wwzet_uuid_resolve(ww, argv[2], strlen(argv[2]), &b);

    if (rc) {
        fprintf(stderr,
                "Could not resolve '%s'\n", argv[2]);
        err = 1;
        goto clean;
    }

    wwzet_link(ww, &a, &b);

    clean:
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);

    return err;
}
#+END_SRC
** search
Performs full-text search on the zet table.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_search(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_search(int argc, char *argv[])
{
    int err;
    weewiki_d *ww;
    int rc;
    sqlite3_stmt *stmt;

    err = 0;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s keyword\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    sqlite3_prepare_v2(weewiki_db(ww),
                       "SELECT time, UUID, value FROM wikizet "
                       "WHERE value MATCH ?1;", -1,
                       &stmt, NULL);

    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *t, *i, *v;

        t = (const char *) sqlite3_column_text(stmt, 0);
        i = (const char *) sqlite3_column_text(stmt, 1);
        v = (const char *) sqlite3_column_text(stmt, 2);

        printf("%s\t%s\t%s\n", t, i, v);
        rc = sqlite3_step(stmt);
    }

    sqlite3_finalize(stmt);
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);

    return err;
}
#+END_SRC
** mkgroup
makes a new group.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_mkgroup(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_mkgroup(int argc, char *argv[])
{
    weewiki_d *ww;
    wwzet_uuid uuid;
    int sz;
    int rc;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s group\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    wwzet_uuid_rng_init();
    wwzet_uuid_init(&uuid);

    sz = strlen(argv[1]);

    rc = wwzet_entry_exists(ww, '@', argv[1], sz);

    if (rc) {
        if (rc == 1) {
            fprintf(stderr, "group '%s' already exists\n", argv[1]);
        }

        /* rc of -1 is a SQLite error */

        return 2;
    }

    wwzet_entry_withsymbol(ww,
                           '@',
                           argv[1],
                           sz,
                           &uuid);
    printf("%s\n", uuid.str);
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return 0;
}
#+END_SRC
** mkpage
Creates an entry linking to an existing weewiki page.

This will check if the page exists first before creating.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_mkpage(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_mkpage(int argc, char *argv[])
{
    weewiki_d *ww;
    wwzet_uuid uuid;
    int rc;
    const char *page;
    int err;
    int sz;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s page\n", argv[0]);
        return 1;
    }

    err = 0;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    page = argv[1];
    sz = strlen(page);

    rc = weewiki_exists(ww, page);

    if (!rc) {
        fprintf(stderr, "Could not find page '%s'\n", page);
        err = 1;
        goto cleanup;
    }

    wwzet_uuid_rng_init();
    wwzet_uuid_init(&uuid);

    rc = wwzet_entry_exists(ww, '!', argv[1], sz);

    if (rc) {
        if (rc == 1) {
            fprintf(stderr, "page '%s' already exists\n", argv[1]);
        }

        /* rc of -1 is a SQLite error */

        return 2;
    }

    wwzet_entry_withsymbol(ww,
                           '!',
                           page,
                           sz,
                           &uuid);

    printf("%s\n", uuid.str);

    cleanup:
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return err;
}
#+END_SRC
** pages
prints list of pages and their UUIDs.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_pages(int argc, char *argv[]);
#+END_SRC

=TODO=: maybe refactor this functionality because it's
virtually identical to =p_groups= minus one character?

#+NAME: funcs
#+BEGIN_SRC c
static int p_pages(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;
    sqlite3 *db;
    sqlite3_stmt *stmt;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);

    sqlite3_prepare_v2(db,
                       "SELECT uuid, value from wikizet "
                       "where value like '!%'",
                       -1, &stmt, NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *uuid;
        const char *value;

        uuid = (const char *)sqlite3_column_text(stmt, 0);
        value = (const char *)sqlite3_column_text(stmt, 1);
        printf("%s\t%s\n", uuid, value + 1);
        rc = sqlite3_step(stmt);
    }

    sqlite3_finalize(stmt);
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** resolve
=resolve= will resolve input argument(s) and print the
UUID(s).

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_resolve(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_resolve(int argc, char *argv[])
{
    weewiki_d *ww;
    int err;
    int i;
    wwzet_uuid id;

    err = 0;

    if (argc == 1) {
        fprintf(stderr,
            "Usage: %s str1 str2 ... strN\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    for (i = 1; i < argc; i++) {
        err = wwzet_uuid_resolve(ww,
                                 argv[i],
                                 strlen(argv[i]),
                                 &id);
        if (err) {
            fprintf(stderr,
                    "Could not resolve '%s'\n",
                    argv[i]);
            break;
        }

        printf("%s\n", id.str);
    }


    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);

    return err;
}
#+END_SRC
** shuffle
Prints N random zet entries given a pattern. Intended to
be used to find random crate files for sample curation
excersizes.

An optional argument provided is (presumably) a group to
ignore. It works by resolving the pattern and getting the
UUID, and ignore all items that link to that UUID.

This is intended to be used for sample curation
and exploration. Samples already auditioned and would be
added to a "listened to" group, which allow randomly chosen
samples to be fresh.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_shuffle(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_shuffle(int argc, char *argv[])
{
    weewiki_d *ww;
    int err;
    int N;
    const char *pat;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    err = 0;

    if (argc < 3) {
        fprintf(stderr,
            "Usage: %s N pattern [ignore]\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    N = atoi(argv[1]);
    pat = argv[2];

    db = weewiki_db(ww);
    stmt = NULL;

    if (argc == 3) {
        sqlite3_prepare_v2(db,
                        "SELECT time, UUID, value "
                        "FROM wikizet "
                        "WHERE value like ?1 "
                        "ORDER BY RANDOM() "
                        "LIMIT ?2;", -1,
                        &stmt, NULL);
        sqlite3_bind_text(stmt, 1, pat, -1, NULL);
        sqlite3_bind_int(stmt, 2, N);
    } else { /* use ignore pattern */
        wwzet_uuid uuid;

        rc = wwzet_uuid_resolve(ww,
                                argv[3], strlen(argv[3]),
                                &uuid);

        if (rc) {
            fprintf(stderr, "Could not resolve '%s'\n", argv[3]);
            err = 1;
            goto cleanup;
        }

        sqlite3_prepare_v2(db,
                        "SELECT time, UUID, value "
                        "FROM wikizet "
                        "WHERE UUID in (SELECT UUID from wikizet "
                        "WHERE value NOT LIKE '#' || ?3) "
                        "AND value LIKE ?1 "
                        "ORDER BY RANDOM() "
                        "LIMIT ?2;", -1,
                        &stmt, NULL);
        sqlite3_bind_text(stmt, 1, pat, -1, NULL);
        sqlite3_bind_int(stmt, 2, N);
        sqlite3_bind_text(stmt, 3, uuid.str, -1, NULL);
    }

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *t;
        const char *u;
        const char *v;

        t = (const char *)sqlite3_column_text(stmt, 0);
        u = (const char *)sqlite3_column_text(stmt, 1);
        v = (const char *)sqlite3_column_text(stmt, 2);

        printf("%s\t%s\t%s\n", (t == NULL ? "-" : t), u, v);

        rc = sqlite3_step(stmt);
    }

    cleanup:
    sqlite3_finalize(stmt);
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);

    return err;
}
#+END_SRC
** groups
prints list of groups and their UUIDs.

If an additional argument is provided, it will try to
resolve that to a UUID then list all the groups it
belongs to.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_groups(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_groups(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;
    sqlite3 *db;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);
    rc = 0;

    if (argc <= 1) {
        sqlite3_stmt *stmt;

        sqlite3_prepare_v2(db,
                        "SELECT uuid, value from wikizet "
                        "where value like '@%'",
                        -1, &stmt, NULL);

        rc = sqlite3_step(stmt);

        while (rc == SQLITE_ROW) {
            const char *uuid;
            const char *value;

            uuid = (const char *)sqlite3_column_text(stmt, 0);
            value = (const char *)sqlite3_column_text(stmt, 1);
            printf("%s\t%s\n", uuid, value + 1);
            rc = sqlite3_step(stmt);
        }
        sqlite3_finalize(stmt);
    } else {
        wwzet_uuid id;
        sqlite3_stmt *stmt;

        rc = wwzet_uuid_resolve(ww,
                                argv[1],
                                strlen(argv[1]),
                                &id);

        if (rc) {
            fprintf(stderr,
                    "Could not resolve '%s'\n",
                    argv[1]);
            goto clean;
        }

        sqlite3_prepare_v2(db,
                           "SELECT UUID, LTRIM(value, '@') FROM wikizet "
                           "WHERE UUID in "
                           "(SELECT LTRIM(value, \"#\") "
                           "FROM wikizet WHERE UUID in "
                           "(SELECT UUID FROM wikizet WHERE "
                           "UUID like ?1) AND "
                           "VALUE like \"#%\") "
                           "AND value like \"@%\";",
                           -1,
                           &stmt, NULL);
        sqlite3_bind_text(stmt, 1, id.str, -1, NULL);

        rc = sqlite3_step(stmt);

        while (rc == SQLITE_ROW) {
            const char *u, *v;

            u = (const char *)sqlite3_column_text(stmt, 0);
            v = (const char *)sqlite3_column_text(stmt, 1);

            printf("%s\t%s\n", u, v);

            rc = sqlite3_step(stmt);
        }
    }

    clean:
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** var
Does things with zet variables. Calls the
variable CLI subprogram.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_var(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_var(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    rc = zet_var(ww, argc, argv);

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);

    return rc;
}
#+END_SRC
** tags
Print tags that a particular UUID is linked to.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_tags(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_tags(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    wwzet_uuid uuid;

    if (argc <= 1) {
        fprintf(stderr, "Usage: %s UUID\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);
    rc = 0;
    rc = wwzet_uuid_resolve(ww,
                            argv[1],
                            strlen(argv[1]),
                            &uuid);
    if (rc) {
        fprintf(stderr, "Could not resolve %s\n", argv[1]);
        goto clean;
    }

    rc = sqlite3_prepare_v2(db,
    "SELECT substr(g.value, 2) from wikizet "
    "INNER JOIN "
    "(SELECT value, UUID FROM wikizet WHERE value LIKE '@%') g "
    "ON wikizet.value = '#' || g.UUID "
    "WHERE wikizet.UUID "
    "LIKE ?1;",
    -1, &stmt, NULL);

    if (rc) {
       fprintf(stderr, "SQLite: %s\n", sqlite3_errmsg(db));
       goto clean;
    }

    sqlite3_bind_text(stmt, 1, uuid.str, -1, NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        printf("%s\n", sqlite3_column_text(stmt, 0));
        rc = sqlite3_step(stmt);
    }

    rc = 0;
    sqlite3_finalize(stmt);

    clean:

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** entry
Usage: entry UUID

Looks up entry UUID and prints all items with that UUID.
Note that the timestamp is printed as localtime not UTC
and should not be used as an exporter to TSV.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_entry(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_entry(int argc, char *argv[])
{
    weewiki_d *ww;
    int rc;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    wwzet_uuid uuid;

    if (argc <= 1) {
        fprintf(stderr, "Usage: %s UUID\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);
    rc = 0;
    rc = wwzet_uuid_resolve(ww,
                            argv[1],
                            strlen(argv[1]),
                            &uuid);
    if (rc) {
        fprintf(stderr, "Could not resolve %s\n", argv[1]);
        goto clean;
    }

    rc = sqlite3_prepare_v2(db,
    "SELECT datetime(time, 'localtime'), UUID, value from wikizet "
    "WHERE wikizet.UUID IS ?1;",
    -1, &stmt, NULL);

    if (rc) {
       fprintf(stderr, "SQLite: %s\n", sqlite3_errmsg(db));
       goto clean;
    }

    sqlite3_bind_text(stmt, 1, uuid.str, -1, NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const char *t, *u, *v;
        t = (const char *)sqlite3_column_text(stmt, 0);
        u = (const char *)sqlite3_column_text(stmt, 1);
        v = (const char *)sqlite3_column_text(stmt, 2);
        printf("%s\t%s\t%s\n", t == NULL ? "-" : t, u, v);
        rc = sqlite3_step(stmt);
    }

    rc = 0;
    sqlite3_finalize(stmt);

    clean:

    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** ergoify
The =ergoify= command takes the UUID an incoming zet tsv
stream and converts it to an ergo ID.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_ergoify(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static size_t smol_getline(char **lineptr, size_t *n, FILE *stream)
{
    char *bufptr = NULL;
    size_t size;
    int c;
    size_t pos;

    if (lineptr == NULL) {
        return -1;
    }

    if (stream == NULL) {
        return -1;
    }

    if (n == NULL) {
        return -1;
    }

    bufptr = *lineptr;
    size = *n;

    c = fgetc(stream);

    if (c == EOF) {
        return -1;
    }

    if (bufptr == NULL) {
        bufptr = malloc(128);
        if (bufptr == NULL) {
            return -1;
        }
        size = 128;
    }

    pos = 0;

    while(c != EOF) {
        if (pos >= (size - 1)) {
            size = size + 128;
            bufptr = realloc(bufptr, size);
            if (bufptr == NULL) {
                return -1;
            }
        }
        bufptr[pos] = (char)c;
        pos++;
        if (c == '\n') {
            break;
        }
        c = fgetc(stream);
    }

    bufptr[pos] = '\0';
    (*lineptr) = bufptr;
    (*n) = size;
    return pos;
}

static int p_ergoify(int argc, char *argv[])
{
    FILE *fp;
    size_t len;
    long read;
    char *line;
    char tmp[64];

    len = 0;
    line = NULL;

    fp = stdin;

    while ((read = smol_getline(&line, &len, fp)) != -1) {
        int off, size;

        off = 0;

        size = 0;

        while (line[off + size] != '\t') size++;
        fwrite(&line[off], 1, size, stdout);

        printf("\tg");
        off += size + 1;
        size = 0;
        while (line[off + size] != '\t') size++;
        wwzet_hex_to_ergo(&line[off], size, tmp);
        /* fwrite(&line[off], 1, size, stdout); */
        fwrite(tmp, 1, size, stdout);

        printf("\t");
        off += size + 1;
        size = read - off;

        fwrite(&line[off], 1, size, stdout);

    }

    free(line);
    return 0;
}
#+END_SRC
** UUID
Generates a UUIDv4 number.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_uuid(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_uuid(int argc, char *argv[])
{
    wwzet_uuid uuid;
    wwzet_uuid_rng_init();
    wwzet_uuid_init(&uuid);
    wwzet_uuid_generate(&uuid);
    fwrite(uuid.str, 1, 36, stdout);
    return 0;
}
#+END_SRC
** ergo
Converts an incoming string to ergo. Ignores non-hexademical
characters.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_ergo(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_ergo(int argc, char *argv[])
{
    int len;

    if (argc == 1) {
        fprintf(stderr, "Usage: %s str\n", argv[0]);
        return 1;
    }

    len = strlen(argv[1]);
    wwzet_hex_to_ergo(argv[1], len, argv[1]);

    fwrite(argv[1], 1, len, stdout);
    fflush(stdout);
    return 0;
}
#+END_SRC
** mkfile
makes a new file path link.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_mkfile(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_mkfile(int argc, char *argv[])
{
    weewiki_d *ww;
    wwzet_uuid uuid;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s file\n", argv[0]);
        return 1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    wwzet_uuid_rng_init();
    wwzet_uuid_init(&uuid);

    wwzet_file(ww, argv[1], strlen(argv[1]), &uuid);
    printf("%s\n", uuid.str);
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return 0;
}
#+END_SRC
** linked
Usage: linked UUID1 UUID2

Will check if a particular link has already been made
between 2 UUIDs (UUID1 -> UUID2)

Will print (and return) 1 if a link has been made already,
and a 0 if it hasn't.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_linked(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_linked(int argc, char *argv[])
{
    weewiki_d *ww;
    wwzet_uuid uuid[2];
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    if (argc < 3) {
        fprintf(stderr, "Usage: %s UUID1 UUID2\n", argv[0]);
        return -1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);
    rc = 0;

    rc = wwzet_uuid_resolve(ww,
                            argv[1],
                            strlen(argv[1]),
                            &uuid[0]);
    if (rc) {
        fprintf(stderr, "Could not resolve %s\n", argv[1]);
        goto clean;
    }

    rc = wwzet_uuid_resolve(ww,
                            argv[2],
                            strlen(argv[2]),
                            &uuid[1]);
    if (rc) {
        fprintf(stderr, "Could not resolve %s\n", argv[2]);
        goto clean;
    }

    rc = sqlite3_prepare_v2(db,
    "SELECT EXISTS(SELECT UUID from wikizet WHERE "
    "UUID is ?1 "
    "AND value IS '#' || ?2);",
    -1, &stmt, NULL);

    if (rc) {
       fprintf(stderr, "SQLite: %s\n", sqlite3_errmsg(db));
       goto clean;
    }

    sqlite3_bind_text(stmt, 1, uuid[0].str, -1, NULL);
    sqlite3_bind_text(stmt, 2, uuid[1].str, -1, NULL);

    rc = sqlite3_step(stmt);

    rc = sqlite3_column_int(stmt, 0);

    if (rc) {
        fprintf(stderr, "%s is already linked to %s\n",
            argv[1], argv[2]);
    }

    sqlite3_finalize(stmt);

    clean:
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
** tie
Usage: tie UUID1 UUID2

Just like =link=, except that it checks to see
if there is a previous link to ensure that it is
not done twice.

In other words, it makes a call to =linked=, then =link=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_tie(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_tie(int argc, char *argv[])
{
    int rc;

    rc = p_linked(argc, argv);

    if (rc) return rc;

    return p_link(argc, argv);
}
#+END_SRC

** belongs
Usage: belongs UUID

Prints any UUIDs that are linked to UUID.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_belongs(int argc, char *argv[]);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static int p_belongs(int argc, char *argv[])
{
    weewiki_d *ww;
    wwzet_uuid uuid;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s UUID\n", argv[0]);
        return -1;
    }

    ww = malloc(weewiki_sizeof());
    weewiki_init(ww);
    weewiki_open(ww, weewiki_dbname_get());

    db = weewiki_db(ww);
    rc = 0;

    rc = wwzet_uuid_resolve(ww,
                            argv[1],
                            strlen(argv[1]),
                            &uuid);
    if (rc) {
        fprintf(stderr, "Could not resolve %s\n", argv[1]);
        goto clean;
    }

    rc = sqlite3_prepare_v2(db,
    "SELECT distinct(UUID) from wikizet "
    "WHERE value IS '#' || ?1;"
    ,
    -1, &stmt, NULL);

    if (rc) {
       fprintf(stderr, "SQLite: %s\n", sqlite3_errmsg(db));
       goto clean;
    }

    sqlite3_bind_text(stmt, 1, uuid.str, -1, NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        const unsigned char *s;
        s = sqlite3_column_text(stmt, 0);
        printf("%s\n", s);
        rc = sqlite3_step(stmt);
    }

    sqlite3_finalize(stmt);

    clean:
    weewiki_close(ww);
    weewiki_clean(ww);
    free(ww);
    return rc;
}
#+END_SRC
