#+TITLE: WeeWiki

WeeWiki is a wee little personal wiki engine, with scripting
capabilities.
* Top Level Files
** C file
#+NAME: weewiki.c
#+BEGIN_SRC c :tangle weewiki.c
#include <stdlib.h>
#include <stdio.h>
#include <sqlite3.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>

#define ORGPARSE_IMPLEMENTATION
#include "orgparse.h"

#include "janet/janet.h"

#include "weewiki.h"
#include "weewiki_private.h"
<<static_funcdefs>>
<<functions>>
static int match(const char *s1,
                 int sz1,
                 const char *s2,
                 int sz2)
{
    return sz1 == sz2 && !strncmp(s1, s2, sz2);
}

int main(int argc, char *argv[])
{
    size_t len;
    if (argc == 1) {
        fprintf(stderr, "Enter a command.\n");
        return 1;
    }
    len = strlen(argv[1]);

    if (0) {

    }
    <<matching>>
    else {
        fprintf(stderr,
                "Could not find command %s\n",
                argv[1]);
    }
    return 0;
}
#+END_SRC
** Header Files
#+NAME: weewiki.h
#+BEGIN_SRC c :tangle weewiki.h
#ifndef WEEWIKI_H
#define WEEWIKI_H
<<typedefs>>
<<funcdefs>>
#endif
#+END_SRC
#+NAME: weewiki_private.h
#+BEGIN_SRC c :tangle weewiki_private.h
#ifndef WEEWIKI_PRIVATE_H
#define WEEWIKI_PRIVATE_H
<<structs>>
#endif
#+END_SRC
* Top Level Struct
** Struct Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct weewiki_d weewiki_d;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct weewiki_d {
    <<contents>>
};
#+END_SRC
** Contents
#+NAME: contents
#+BEGIN_SRC c
sqlite3 *db;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->db = NULL;
#+END_SRC
#+NAME: clean
#+BEGIN_SRC c
if (ww->db != NULL) {
    weewiki_close(ww);
}
#+END_SRC
** Init
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_init(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_init(weewiki_d *ww)
{
    <<init>>
}
#+END_SRC
** Cleanup
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_clean(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_clean(weewiki_d *ww)
{
    <<clean>>
}
#+END_SRC
* DONE Database
CLOSED: [2019-09-14 Sat 12:46]
** Open
A database is opened with =weewiki_open=.
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_open(weewiki_d *ww, const char *filename);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_open(weewiki_d *ww, const char *filename)
{
    sqlite3 *db;
    int rc;

    ww->db = NULL;
    rc = sqlite3_open(filename, &db);
    if (rc) {
        fprintf(stderr,
                "Could not open database: %s",
                sqlite3_errmsg(db));
        sqlite3_close(db);
        return 0;
    }

    ww->db = db;
    weewiki_create_tables(ww);
    return 1;
}
#+END_SRC
** Close
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_close(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_close(weewiki_d *ww)
{
    sqlite3_close(ww->db);
    ww->db = NULL;
}
#+END_SRC
** Get
** Create Tables
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_create_tables(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_create_tables(weewiki_d *ww)
{
    sqlite3_exec(ww->db,
                "CREATE TABLE IF NOT EXISTS wiki(\n"
                "key TEXT UNIQUE,\n"
                "value TEXT\n"
                ");\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db,
                "CREATE TABLE IF NOT EXISTS wikilinks(\n"
                "key TEXT UNIQUE,\n"
                "filename TEXT,\n"
                "mtime INTEGER\n"
                ");\n",
                NULL,
                NULL,
                NULL);
}
#+END_SRC
** Push
Low level operation that pushes a file to a key.
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_push(weewiki_d *ww,
                 const char *fname,
                 const char *key);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_push(weewiki_d *ww,
                 const char *fname,
                 const char *key)
{
    char *buf;
    size_t sz;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    FILE *fp;

    fp = fopen(fname, "r");

    if (fp == NULL) {
        fprintf(stderr,
                "Could not open file %s reading.\n",
                fname);
        return 1;
    }

    fseek(fp, 0, SEEK_END);
    sz = ftell(fp);
    buf = calloc(1, sz + 1);
    fseek(fp, 0, SEEK_SET);
    fread(buf, 1, sz, fp);

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "INSERT OR REPLACE INTO wiki"
                       "(key, value)\n"
                       "VALUES(?1,?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, buf, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr,
                "SQLite error: %s\n",
                sqlite3_errmsg(db));
         return 1;
    }
    sqlite3_finalize(stmt);

    free(buf);
    return 0;
}
#+END_SRC
** Pull
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_pull(weewiki_d *ww,
                 const char *key,
                 const char *fname);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_pull(weewiki_d *ww,
                 const char *key,
                 const char *fname)
{
    size_t sz;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    FILE *fp;

    fp = fopen(fname, "w");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not open file %s for writing\n",
                fname);
        return 1;
    }

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT value FROM wiki WHERE(key==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr,
                "Could not find key '%s'\n",
                key);
        sqlite3_finalize(stmt);
        return 1;
    }

    sz = sqlite3_column_bytes(stmt, 0);
    fwrite(sqlite3_column_text(stmt, 0), 1, sz, fp);
    sqlite3_finalize(stmt);
    fclose(fp);
    return 0;
}
#+END_SRC
** Exists
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_exists(weewiki_d *ww, const char *key);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_exists(weewiki_d *ww, const char *key)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT EXISTS("
                       "SELECT * FROM wiki WHERE(key==?1)"
                       ");",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);

    sqlite3_step(stmt);

    rc = sqlite3_column_int(stmt, 0);

    sqlite3_finalize(stmt);
    return rc;
}
#+END_SRC
* DONE Push/Pull
CLOSED: [2019-09-14 Sat 10:44]
** DONE Push
CLOSED: [2019-09-14 Sat 09:24]
Pushes a file to database.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "push", 4)) {
    argc--;
    argv++;
    return p_push(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_push(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_push(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s file key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = weewiki_push(&ww, argv[1], argv[2]);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** DONE Pull
CLOSED: [2019-09-14 Sat 10:16]
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "pull", 4)) {
    argc--;
    argv++;
    return p_pull(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_pull(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_pull(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s file key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = weewiki_pull(&ww, argv[1], argv[2]);
    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* DONE Edit
CLOSED: [2019-09-14 Sat 12:46]
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "edit", 4)) {
    argc--;
    argv++;
    return p_edit(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_edit(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_edit(int argc, char *argv[])
{
    weewiki_d ww;
    char fname[128];
    char cmd[256];
    struct tm tm;
    time_t t;
    FILE *fp;

    t = time(NULL);
    tm = *localtime(&t);

    strftime(fname, 128128, "tmp_%m%d%y%H%M%S.org", &tm);
    fprintf(stderr, "tmpname is %s\n", fname);

    if (argc < 2) {
        fprintf(stderr,
                "Usage: %s key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    if (weewiki_exists(&ww, argv[1])) {
        fprintf(stderr, "pulling %s to %s\n", argv[1], fname);
        weewiki_pull(&ww, argv[1], fname);
    } else {
        fp = fopen(fname, "w");
        fprintf(fp, "A new page.");
        fclose(fp);
    }

    sprintf(cmd, "$EDITOR %s", fname);
    system(cmd);
    weewiki_push(&ww, fname, argv[1]);
    weewiki_close(&ww);
    weewiki_clean(&ww);
    remove(fname);
    return 1;
}
#+END_SRC
* ls
List all pages.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "ls", 2)) {
    argc--;
    argv++;
    return p_ls(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_ls(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int list(void *ud, int sz, char **argv, char **col)
{
    int n;
    for(n = 0; n < sz; n++) {
        printf("%s\n", argv[n]);
    }
    return 0;
}
static int p_ls(int argc, char *argv[])
{
    weewiki_d ww;

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    sqlite3_exec(ww.db,
                 "SELECT key FROM wiki;",
                 list,
                 NULL,
                 NULL);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return 0;
}
#+END_SRC
* Link
The "link" operation will link a page to a filepath.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "link", 4)) {
    argc--;
    argv++;
    return p_link(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_link(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_link(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    struct stat st;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s key file\n",
                argv[0]);
        return 1;
    }

    if (access(argv[2], F_OK) != -1) {
        fprintf(stderr, "%s: file exists.\n", argv[2]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = weewiki_pull(&ww, argv[1], argv[2]);

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "INSERT OR REPLACE INTO wikilinks"
                       "(key, filename, mtime)\n"
                       "VALUES(?1,?2,?3);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    sqlite3_bind_text(stmt, 2, argv[2], -1, NULL);
    stat(argv[2], &st);
    sqlite3_bind_int(stmt, 3, st.st_mtime);

    sqlite3_step(stmt);

    sqlite3_finalize(stmt);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* DONE Sync
CLOSED: [2019-09-23 Mon 12:09]
The =sync= command is used to sync files between the
database and external files. It will iterate through the
=wikilinks= tables and update things by comparing internal
modification times.

If the external mtime is greater, the file is pushed to the
table.

If the internal mtime is greater, the file is pulled from
table.

If the times are equal, no action happens.

If the external file doesn't exist, it is treated as a
"pull" operation.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "sync", 4)) {
    argc--;
    argv++;
    return p_sync(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_sync(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void update_mtime(weewiki_d *ww,
                         const char *fname,
                         const char *key)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    struct stat st;
    unsigned int mtime;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "UPDATE wikilinks SET mtime=?1 "
                       "WHERE (key==?2);",
                       -1,
                       &stmt,
                       NULL);

    stat(fname, &st);
    mtime = st.st_mtime;

    sqlite3_bind_int(stmt, 1, mtime);
    sqlite3_bind_text(stmt, 2, key, -1, NULL);

    sqlite3_step(stmt);
    sqlite3_finalize(stmt);
}

static int sync_file(weewiki_d *ww, sqlite3_stmt *stmt)
{
    int rc;
    const char *fname;
    const char *key;
    unsigned int int_mtime;
    unsigned int ext_mtime;
    struct stat st;

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) return 0;
    key = (const char *)sqlite3_column_text(stmt, 0);
    fname = (const char *)sqlite3_column_text(stmt, 1);
    int_mtime = sqlite3_column_int(stmt, 2);

    if (access(fname, F_OK) == -1) {
        ext_mtime = 0;
    } else {
        stat(fname, &st);
        ext_mtime = st.st_mtime;
    }

    if (int_mtime == ext_mtime) {
        printf("SKIP %s\n", key);
    } else if (ext_mtime > int_mtime) {
        printf("PUSH %s %s\n", fname, key);
        weewiki_push(ww, fname, key);
        update_mtime(ww, fname, key);
    } else if (int_mtime > ext_mtime) {
        printf("PULL %s %s\n", key, fname);
        weewiki_pull(ww, key, fname);
    }

    return 1;
}

static int p_sync(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    if (access(argv[2], F_OK) != -1) {
        fprintf(stderr, "%s: file exists.\n", argv[2]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "SELECT key, filename, mtime "
                       "FROM wikilinks;",
                       -1,
                       &stmt,
                       NULL);

    while (1) {
        if (!sync_file(&ww, stmt)) {
            rc = 1;
            break;
        }
    }

    sqlite3_finalize(stmt);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* TODO New/Delete
* TODO Export
** Command
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "export", 6)) {
    argc--;
    argv++;
    return p_export(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_export(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_export(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;
    weewiki_export_d ex;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    FILE *config;
    char *tmp;
    size_t config_sz;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s page\n", argv[0]);
        return 1;
    }

    rc = 0;

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    if (!weewiki_exists(&ww, argv[1])) {
        fprintf(stderr,
                "Could not find page '%s'\n",
                argv[1]);
        rc = 1;
    }

    if (!rc) {
        db = ww.db;
        sqlite3_prepare_v2(db,
                           "SELECT value "
                           "FROM wiki WHERE (key==?1);",
                           -1,
                           &stmt,
                           NULL);

        sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
        sqlite3_step(stmt);

        ex.fp = stdout;
        janet_init();
        ex.env = janet_core_env(NULL);
        janet_dostring(ex.env,
                       "(defn html-header () ())"
                       "(defn html-footer () ())",
                       NULL, NULL);

        config = fopen("weewiki.janet", "r");

        if (config != NULL) {
            fseek(config, 0, SEEK_END);
            config_sz = ftell(config);
            tmp = calloc(1, config_sz + 1);
            fseek(config, 0, SEEK_SET);
            fread(tmp, 1, config_sz, config);
            fclose(config);
            janet_dostring(ex.env, tmp, NULL, NULL);
            free(tmp);
        }

        janet_dostring(ex.env, "(html-header)", NULL, NULL);

        weewiki_orgparse_setup(&ex.op);
        weewiki_export_run(&ex,
                           (const char *)sqlite3_column_text(stmt, 0),
                           sqlite3_column_bytes(stmt, 0));
        sqlite3_finalize(stmt);

        janet_dostring(ex.env, "(html-footer)", NULL, NULL);

        janet_deinit();
    }

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** Orgparse Export Struct
This is a struct passed into orgparse.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct weewiki_export_d weewiki_export_d;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct weewiki_export_d {
    weewiki_d *ww;
    FILE *fp;
    orgparse op;
    JanetTable *env;
};
#+END_SRC
** Orgparse callback setup
Orgparse is used to parse a text buffer and generate HTML
content. To do this, a series of callbacks are implemented.
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_orgparse_setup(orgparse *op);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
<<orgparse_callbacks>>
void weewiki_orgparse_setup(orgparse *op)
{
    orgparse_init(op);
    <<orgparse_html_setup>>
}
#+END_SRC
*** Header
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_header(void *ud,
                        const char *h,
                        size_t sz,
                        int lvl)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    lvl++;
    fprintf(fp, "<h%d>", lvl);
    fwrite(h, 1, sz, fp);
    fprintf(fp, "</h%d>\n", lvl);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_header(op, html_header);
#+END_SRC
*** Text
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_text(void *ud,
                      const char *str,
                      size_t sz)
{
    fwrite(str, 1, sz, stdout);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_text(op, html_text);
#+END_SRC
*** Bold
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_bold(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("<b>");
    fwrite(str, 1, sz, stdout);
    printf("</b>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_bold(op, html_bold);
#+END_SRC
*** Aux
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_aux(void *ud,
                     const char *str,
                     size_t sz)
{
    weewiki_export_d *ex;
    ex = ud;
    janet_dobytes(ex->env,
                  (const uint8_t *)str, sz,
                  NULL, NULL);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_aux(op, html_aux);
#+END_SRC
*** Newline
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_newline(void *ud,
                         const char *str,
                         size_t sz)
{
    printf("<br>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_newline(op, html_newline);
#+END_SRC
*** Code
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_code(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("<code>");
    fwrite(str, 1, sz, stdout);
    printf("'</code>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_code(op, html_code);
#+END_SRC
*** Code Block
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_codeblock(void *ud,
                           const char *str,
                           size_t sz)
{
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_codeblock(op, html_codeblock);
#+END_SRC
*** Name
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_name(void *ud,
                           const char *str,
                           size_t sz)
{
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_name(op, html_name);
#+END_SRC
*** Title
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_title(void *ud,
                           const char *str,
                           size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<title>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</title>\n");
    fprintf(fp, "<h1>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</h1>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_title(op, html_title);
#+END_SRC
** Run
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_export_run(weewiki_export_d *ex,
                        const char *buf,
                        size_t sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_export_run(weewiki_export_d *ex,
                        const char *buf,
                        size_t sz)
{
    orgparse_run(&ex->op, buf, sz, ex);
}
#+END_SRC
