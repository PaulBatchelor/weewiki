#+TITLE: WeeWiki

WeeWiki is a wee little personal wiki engine, with scripting
capabilities.
* Top Level Files
** C file
#+NAME: weewiki.c
#+BEGIN_SRC c :tangle weewiki.c
#include <stdlib.h>
#include <stdio.h>
#include <sqlite3.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>

#define ORGPARSE_IMPLEMENTATION
#include "orgparse.h"

#include "weewiki.h"
#include "weewiki_private.h"
#include "jan.h"
<<global_data>>
<<static_funcdefs>>
<<functions>>
static int match(const char *s1,
                 int sz1,
                 const char *s2,
                 int sz2)
{
    return sz1 == sz2 && !strncmp(s1, s2, sz2);
}

int main(int argc, char *argv[])
{
    size_t len;
    if (argc == 1) {
        fprintf(stderr, "Enter a command.\n");
        return 1;
    }
    len = strlen(argv[1]);

    if (0) {

    }
    <<matching>>
    else {
        fprintf(stderr,
                "Could not find command %s\n",
                argv[1]);
    }
    return 0;
}
#+END_SRC
** Header Files
#+NAME: weewiki.h
#+BEGIN_SRC c :tangle weewiki.h
#ifndef WEEWIKI_H
#define WEEWIKI_H
#ifndef JANET_H_defined
#include <stdint.h>
typedef struct JanetTable JanetTable;
typedef struct Janet Janet;
int janet_dostring(JanetTable *env,
                   const uint8_t *bytes,
                   const char *sourcePath,
                   Janet *out);
int janet_dobytes(JanetTable *env,
                  const uint8_t *bytes,
                  int32_t len,
                  const char *sourcePath,
                  Janet *out);
#endif

<<typedefs>>
<<funcdefs>>
#endif
#+END_SRC
#+NAME: weewiki_private.h
#+BEGIN_SRC c :tangle weewiki_private.h
#ifndef WEEWIKI_PRIVATE_H
#define WEEWIKI_PRIVATE_H
<<structs>>
#endif
#+END_SRC
* Top Level Struct
** Struct Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct weewiki_d weewiki_d;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct weewiki_d {
    <<contents>>
};
#+END_SRC
** Contents
*** SQLite database
#+NAME: contents
#+BEGIN_SRC c
sqlite3 *db;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->db = NULL;
#+END_SRC
#+NAME: clean
#+BEGIN_SRC c
if (ww->db != NULL) {
    weewiki_close(ww);
}
#+END_SRC
*** Global filehandle
#+NAME: contents
#+BEGIN_SRC c
FILE *fp;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->fp = stdout;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
FILE * weewiki_fp(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
FILE * weewiki_fp(weewiki_d *ww)
{
    if (ww == NULL) return stdout;
    else return ww->fp;
}
#+END_SRC
*** Global Exporter
#+NAME: contents
#+BEGIN_SRC c
weewiki_export_d *ex;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->ex = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
weewiki_export_d * weewiki_ex(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
weewiki_export_d * weewiki_ex(weewiki_d *ww)
{
    return ww->ex;
}
#+END_SRC
** Init
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_init(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_init(weewiki_d *ww)
{
    <<init>>
}
#+END_SRC
** Cleanup
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_clean(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_clean(weewiki_d *ww)
{
    <<clean>>
}
#+END_SRC
** Global Data Instance
To make integration with Janet easier, a global =weewiki_d=
pointer is used.

For the janet standalone, a global variable is set and used
by default.
#+NAME: global_data
#+BEGIN_SRC c
static weewiki_d iWeeWiki;
static weewiki_d *WeeWiki = &iWeeWiki;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_set(weewiki_d *ww);
weewiki_d *weewiki_get(void);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_set(weewiki_d *ww)
{
    WeeWiki = ww;
}

weewiki_d *weewiki_get(void)
{
    return WeeWiki;
}
#+END_SRC
* High Level Functions
Designed to be used inside Janet scripts.
** Add Page
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_add_page(weewiki_d *ww,
                      const char *key,
                      const char *val);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_add_page(weewiki_d *ww,
                      const char *key,
                      const char *val)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "INSERT INTO wiki"
                       "(key, value)\n"
                       "VALUES(?1, ?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, val, -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);
}
#+END_SRC
** Link Page
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_add_link(weewiki_d *ww,
                      const char *key,
                      const char *fname);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_add_link(weewiki_d *ww,
                      const char *key,
                      const char *fname)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "INSERT INTO wikilinks"
                       "(key, filename)\n"
                       "VALUES(?1, ?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, fname, -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);
}
#+END_SRC
** Sync
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_sync(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void update_mtime(weewiki_d *ww,
                         const char *fname,
                         const char *key)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    struct stat st;
    unsigned int mtime;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "UPDATE wikilinks SET mtime=?1 "
                       "WHERE (key==?2);",
                       -1,
                       &stmt,
                       NULL);

    stat(fname, &st);
    mtime = st.st_mtime;

    sqlite3_bind_int(stmt, 1, mtime);
    sqlite3_bind_text(stmt, 2, key, -1, NULL);

    sqlite3_step(stmt);
    sqlite3_finalize(stmt);
}

static int sync_file(weewiki_d *ww, sqlite3_stmt *stmt)
{
    int rc;
    const char *fname;
    const char *key;
    unsigned int int_mtime;
    unsigned int ext_mtime;
    struct stat st;

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) return 0;
    key = (const char *)sqlite3_column_text(stmt, 0);
    fname = (const char *)sqlite3_column_text(stmt, 1);
    int_mtime = sqlite3_column_int(stmt, 2);

    if (access(fname, F_OK) == -1) {
        ext_mtime = 0;
    } else {
        stat(fname, &st);
        ext_mtime = st.st_mtime;
    }

    if (int_mtime == ext_mtime) {
        printf("SKIP %s\n", key);
    } else if (ext_mtime > int_mtime) {
        printf("PUSH %s %s\n", fname, key);
        weewiki_push(ww, fname, key);
        update_mtime(ww, fname, key);
    } else if (int_mtime > ext_mtime) {
        printf("PULL %s %s\n", key, fname);
        weewiki_pull(ww, key, fname);
    }

    return 1;
}

int weewiki_sync(weewiki_d *ww)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = 0;
    db = ww->db;

    sqlite3_prepare_v2(db,
                       "SELECT key, filename, mtime "
                       "FROM wikilinks;",
                       -1,
                       &stmt,
                       NULL);

    while (1) {
        if (!sync_file(ww, stmt)) {
            break;
        }
    }

    sqlite3_finalize(stmt);
    return rc;
}
#+END_SRC
** Clear
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_clear(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_clear(weewiki_d *ww)
{
    sqlite3_exec(ww->db,
                "DELETE FROM wiki WHERE 1;\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db,
                "DELETE FROM wikilinks WHERE 1;\n",
                NULL,
                NULL,
                NULL);
}
#+END_SRC
* Database
** Open
A database is opened with =weewiki_open=.
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_open(weewiki_d *ww, const char *filename);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_open(weewiki_d *ww, const char *filename)
{
    sqlite3 *db;
    int rc;

    ww->db = NULL;
    rc = sqlite3_open(filename, &db);
    if (rc) {
        fprintf(stderr,
                "Could not open database: %s",
                sqlite3_errmsg(db));
        sqlite3_close(db);
        return 0;
    }

    ww->db = db;
    weewiki_create_tables(ww);
    return 1;
}
#+END_SRC
** Close
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_close(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_close(weewiki_d *ww)
{
    sqlite3_close(ww->db);
    ww->db = NULL;
}
#+END_SRC
** Get
** Create Tables
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_create_tables(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_create_tables(weewiki_d *ww)
{
    sqlite3_exec(ww->db,
                "CREATE TABLE IF NOT EXISTS wiki(\n"
                "key TEXT UNIQUE,\n"
                "value TEXT\n"
                ");\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db,
                "CREATE TABLE IF NOT EXISTS wikilinks(\n"
                "key TEXT UNIQUE,\n"
                "filename TEXT,\n"
                "mtime INTEGER\n"
                ");\n",
                NULL,
                NULL,
                NULL);
}
#+END_SRC
** Push
Low level operation that pushes a file to a key.
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_push(weewiki_d *ww,
                 const char *fname,
                 const char *key);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_push(weewiki_d *ww,
                 const char *fname,
                 const char *key)
{
    char *buf;
    size_t sz;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    FILE *fp;

    fp = fopen(fname, "r");

    if (fp == NULL) {
        fprintf(stderr,
                "Could not open file %s reading.\n",
                fname);
        return 1;
    }

    fseek(fp, 0, SEEK_END);
    sz = ftell(fp);
    buf = calloc(1, sz + 1);
    fseek(fp, 0, SEEK_SET);
    fread(buf, 1, sz, fp);

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "INSERT OR REPLACE INTO wiki"
                       "(key, value)\n"
                       "VALUES(?1,?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, buf, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr,
                "SQLite error: %s\n",
                sqlite3_errmsg(db));
         return 1;
    }
    sqlite3_finalize(stmt);

    free(buf);
    return 0;
}
#+END_SRC
** Pull
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_pull(weewiki_d *ww,
                 const char *key,
                 const char *fname);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_pull(weewiki_d *ww,
                 const char *key,
                 const char *fname)
{
    size_t sz;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    FILE *fp;

    fp = fopen(fname, "w");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not open file %s for writing\n",
                fname);
        return 1;
    }

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT value FROM wiki WHERE(key==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr,
                "Could not find key '%s'\n",
                key);
        sqlite3_finalize(stmt);
        return 1;
    }

    sz = sqlite3_column_bytes(stmt, 0);
    fwrite(sqlite3_column_text(stmt, 0), 1, sz, fp);
    sqlite3_finalize(stmt);
    fclose(fp);
    return 0;
}
#+END_SRC
** Exists
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_exists(weewiki_d *ww, const char *key);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_exists(weewiki_d *ww, const char *key)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT EXISTS("
                       "SELECT * FROM wiki WHERE(key==?1)"
                       ");",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);

    sqlite3_step(stmt);

    rc = sqlite3_column_int(stmt, 0);

    sqlite3_finalize(stmt);
    return rc;
}
#+END_SRC
* Push/Pull
** DONE Push
CLOSED: [2019-09-14 Sat 09:24]
Pushes a file to database.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "push", 4)) {
    argc--;
    argv++;
    return p_push(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_push(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_push(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s file key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = weewiki_push(&ww, argv[1], argv[2]);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** DONE Pull
CLOSED: [2019-09-14 Sat 10:16]
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "pull", 4)) {
    argc--;
    argv++;
    return p_pull(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_pull(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_pull(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s file key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = weewiki_pull(&ww, argv[1], argv[2]);
    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Edit
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "edit", 4)) {
    argc--;
    argv++;
    return p_edit(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_edit(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_edit(int argc, char *argv[])
{
    weewiki_d ww;
    char fname[128];
    char cmd[256];
    struct tm tm;
    time_t t;
    FILE *fp;

    t = time(NULL);
    tm = *localtime(&t);

    strftime(fname, 128128, "tmp_%m%d%y%H%M%S.org", &tm);
    fprintf(stderr, "tmpname is %s\n", fname);

    if (argc < 2) {
        fprintf(stderr,
                "Usage: %s key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    if (weewiki_exists(&ww, argv[1])) {
        fprintf(stderr, "pulling %s to %s\n", argv[1], fname);
        weewiki_pull(&ww, argv[1], fname);
    } else {
        fp = fopen(fname, "w");
        fprintf(fp, "A new page.");
        fclose(fp);
    }

    sprintf(cmd, "$EDITOR %s", fname);
    system(cmd);
    weewiki_push(&ww, fname, argv[1]);
    weewiki_close(&ww);
    weewiki_clean(&ww);
    remove(fname);
    return 1;
}
#+END_SRC
* ls
List all pages.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "ls", 2)) {
    argc--;
    argv++;
    return p_ls(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_ls(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int list(void *ud, int sz, char **argv, char **col)
{
    int n;
    for(n = 0; n < sz; n++) {
        if (n != 0) printf(" ");
        printf("%s", argv[n]);
    }
    printf("\n");
    return 0;
}

static int p_ls(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = 0;

    if (argc == 1) {
        sqlite3_exec(ww.db,
                    "SELECT key FROM wiki;",
                    list,
                    NULL,
                    NULL);
    } else if (argc == 2) {
        if (!strcmp(argv[1], "links")) {
            sqlite3_exec(ww.db,
                        "SELECT key, filename FROM wikilinks;",
                        list,
                        NULL,
                        NULL);
        } else {
            fprintf(stderr, 
                    "Invalid command '%s'\n",
                    argv[1]);
            rc = 1;
        }
    }

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Link
The "link" operation will link a page to a filepath.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "link", 4)) {
    argc--;
    argv++;
    return p_link(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_link(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_link(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    struct stat st;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s key file\n",
                argv[0]);
        return 1;
    }

    if (access(argv[2], F_OK) != -1) {
        fprintf(stderr, "%s: file exists.\n", argv[2]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = weewiki_pull(&ww, argv[1], argv[2]);

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "INSERT OR REPLACE INTO wikilinks"
                       "(key, filename, mtime)\n"
                       "VALUES(?1,?2,?3);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    sqlite3_bind_text(stmt, 2, argv[2], -1, NULL);
    stat(argv[2], &st);
    sqlite3_bind_int(stmt, 3, st.st_mtime);

    sqlite3_step(stmt);

    sqlite3_finalize(stmt);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Sync
The =sync= command is used to sync files between the
database and external files. It will iterate through the
=wikilinks= tables and update things by comparing internal
modification times.

If the external mtime is greater, the file is pushed to the
table.

If the internal mtime is greater, the file is pulled from
table.

If the times are equal, no action happens.

If the external file doesn't exist, it is treated as a
"pull" operation.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "sync", 4)) {
    argc--;
    argv++;
    return p_sync(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_sync(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_sync(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (access(argv[2], F_OK) != -1) {
        fprintf(stderr, "%s: file exists.\n", argv[2]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    rc = weewiki_sync(&ww);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Add/Remove Page
Adds/removes a new page.
** add
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "add", 3)) {
    argc--;
    argv++;
    return p_add(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_add(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_add(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = 0;
    if (argc < 2) {
        fprintf(stderr,
                "Usage: %s key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "INSERT INTO wiki"
                       "(key)\n"
                       "VALUES(?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** del
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "del", 3)) {
    argc--;
    argv++;
    return p_del(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_del(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_del(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = 0;
    if (argc < 2) {
        fprintf(stderr,
                "Usage: %s key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "DELETE FROM wiki "
                       "WHERE (key ==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);

    sqlite3_prepare_v2(db,
                       "DELETE FROM wikilinks "
                       "WHERE (key ==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Export
** Command
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "export", 6)) {
    argc--;
    argv++;
    return p_export(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_export(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_export(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;
    weewiki_export_d ex;
    sqlite3 *db;
    const unsigned char *dir;
    int export_page;

    if (argc < 2) {
        export_page = 0;
    } else {
        export_page = 1;
    }

    rc = 0;

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    if (!rc) {
        db = ww.db;
        weewiki_set(&ww);

        weewiki_orgparse_setup(&ex.op);
        ex.env = weewiki_janet_setup();

        weewiki_janet_loadconfig(ex.env);
        dir = weewiki_janet_wwdir(ex.env);

        if (export_page) {
            write_single_file(&ww, &ex, db, dir, argv[1]);
        } else {
            write_multiple_files(&ww, &ex, db, dir);
        }

        weewiki_janet_cleanup();
    }

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** Orgparse Export Struct
This is a struct passed into orgparse.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct weewiki_export_d weewiki_export_d;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct weewiki_export_d {
    weewiki_d *ww;
    FILE *fp;
    orgparse op;
    JanetTable *env;
    orgparse_state state;
};
#+END_SRC
** Orgparse callback setup
Orgparse is used to parse a text buffer and generate HTML
content. To do this, a series of callbacks are implemented.
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_orgparse_setup(orgparse *op);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
<<orgparse_callbacks>>
void weewiki_orgparse_setup(orgparse *op)
{
    orgparse_init(op);
    <<orgparse_html_setup>>
}
#+END_SRC
*** Header
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_header(void *ud,
                        const char *h,
                        size_t sz,
                        int lvl)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    lvl++;
    fprintf(fp, "\n<h%d>", lvl);
    fwrite(h, 1, sz, fp);
    fprintf(fp, "</h%d>\n\n", lvl);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_header(op, html_header);
#+END_SRC
*** Text
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_text(void *ud,
                      const char *str,
                      size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fwrite(str, 1, sz, fp);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_text(op, html_text);
#+END_SRC
*** Bold
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_bold(void *ud,
                      const char *str,
                      size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<b>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</b>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_bold(op, html_bold);
#+END_SRC
*** Aux
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_aux(void *ud,
                     const char *str,
                     size_t sz)
{
    weewiki_export_d *ex;
    ex = ud;
    janet_dobytes(ex->env,
                  (const uint8_t *)str, sz,
                  NULL, NULL);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_aux(op, html_aux);
#+END_SRC
*** Newline
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_newline(void *ud,
                         const char *str,
                         size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<br>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_newline(op, html_newline);
#+END_SRC
*** Code
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_code(void *ud,
                      const char *str,
                      size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<code>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</code>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_code(op, html_code);
#+END_SRC
*** Code Block
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_codeblock(void *ud,
                           const char *str,
                           size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    size_t n;
    ex = ud;
    fp = ex->fp;

    fprintf(fp, "<pre><code>");
    for (n = 0; n < sz; n++) {
        switch (str[n]) {
            default:
                fputc(str[n], fp);
                break;
        }
    }
    fprintf(fp, "</pre></code>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_codeblock(op, html_codeblock);
#+END_SRC
*** Name
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_name(void *ud,
                           const char *str,
                           size_t sz)
{
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_name(op, html_name);
#+END_SRC
*** Title
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_title(void *ud,
                           const char *str,
                           size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<title>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</title>\n");
    fprintf(fp, "<h1>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</h1>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_title(op, html_title);
#+END_SRC
*** Link
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_link(void *ud,
                      const char *link,
                      size_t link_sz,
                      const char *name,
                      size_t name_sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<a href=\"");
    fwrite(link, 1, link_sz, fp);
    fprintf(fp, "\">");
    fwrite(name, 1, name_sz, fp);
    fprintf(fp, "</a>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_link(op, html_link);
#+END_SRC
*** Paragraph
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_pgrph(void *ud, int mode)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;

    if (mode) {
        fprintf(fp, "</p>\n");
    } else {
        fprintf(fp, "<p>");
    }
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_pgrph(op, html_pgrph);
#+END_SRC
** Run
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_export_run(weewiki_export_d *ex,
                       const char *buf,
                       size_t sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_export_run(weewiki_export_d *ex,
                       const char *buf,
                       size_t sz)
{
    orgparse_state_init(&ex->state, &ex->op, buf, sz, ex);
    return orgparse_state_run(&ex->state);
}
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_export_run_txtmode(weewiki_export_d *ex,
                               const char *buf,
                               size_t sz,
                               int txtmode);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_export_run_txtmode(weewiki_export_d *ex,
                               const char *buf,
                               size_t sz,
                               int txtmode)
{
    return orgparse_run_txtmode(&ex->op,
                                buf, sz,
                                ex,
                                txtmode);
}
#+END_SRC
** Write File
This generates a file
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void write_file(weewiki_export_d *ex,
                       const unsigned char *txt,
                       size_t txt_sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void write_file(weewiki_export_d *ex,
                       const unsigned char *txt,
                       size_t txt_sz)
{
    int rc;
    janet_dostring(ex->env,
                   (const unsigned char *)"(html-header)",
                   NULL, NULL);
    rc = weewiki_export_run(ex,
                            (const char *)txt,
                            txt_sz);
    orgparse_wrapup(&ex->op, ex, rc);
    janet_dostring(ex->env,
                   (const unsigned char *)"(html-footer)",
                   NULL, NULL);
}
#+END_SRC
** Make Filehandle
Generates a filehandle. If null values are passed in,
return =stdout=.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static FILE * mkfile(const unsigned char *dir,
                     const unsigned char *name);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static FILE * mkfile(const unsigned char *dir,
                     const unsigned char *name)
{
    FILE *fp;
    char tmp[256];
    if (name == NULL) return stdout;
    sprintf(tmp, "%s/%s.html", dir, name);
    fp = fopen(tmp, "w");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not write to file %s\n",
                tmp);
    }
    return fp;
}
#+END_SRC
** Write Single File
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void write_single_file(weewiki_d *ww,
                              weewiki_export_d *ex,
                              sqlite3 *db,
                              const unsigned char *dir,
                              const char *name);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void write_single_file(weewiki_d *ww,
                              weewiki_export_d *ex,
                              sqlite3 *db,
                              const unsigned char *dir,
                              const char *name)
{
    sqlite3_stmt *stmt;

    if (!weewiki_exists(ww, name)) {
        fprintf(stderr,
                "Could not find page '%s'\n",
                name);
        return;
    }

    sqlite3_prepare_v2(db,
                        "SELECT value "
                        "FROM wiki WHERE (key==?1);",
                        -1,
                        &stmt,
                        NULL);

    sqlite3_bind_text(stmt, 1, name, -1, NULL);
    sqlite3_step(stmt);

    ex->fp = mkfile(dir, NULL);
    ww->fp = ex->fp;
    ww->ex = ex;

    write_file(ex,
               sqlite3_column_text(stmt, 0),
               sqlite3_column_bytes(stmt, 0));

    sqlite3_finalize(stmt);

}
#+END_SRC
** Write Multiple Files
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void write_multiple_files(weewiki_d *ww,
                                 weewiki_export_d *ex,
                                 sqlite3 *db,
                                 const unsigned char *dir);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void write_multiple_files(weewiki_d *ww,
                                 weewiki_export_d *ex,
                                 sqlite3 *db,
                                 const unsigned char *dir)
{
    sqlite3_stmt *stmt;
    int rc;
    const unsigned char *key;

    sqlite3_prepare_v2(db,
                        "SELECT key, value "
                        "FROM wiki;",
                        -1,
                        &stmt,
                        NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        key = sqlite3_column_text(stmt, 0);
        ex->fp = mkfile(dir,
                        sqlite3_column_text(stmt, 0));
        ww->fp = ex->fp;
        ww->ex = ex;
        if (ex->fp != NULL) {
            fprintf(stdout, "Writing %s\n", key);
            write_file(ex,
                    sqlite3_column_text(stmt, 1),
                    sqlite3_column_bytes(stmt, 1));
            fclose(ex->fp);
        } else {
            break;
        }
        rc = sqlite3_step(stmt);
    }


    sqlite3_finalize(stmt);
}
#+END_SRC
** Weewiki Export Text Mode
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_export_txtmode(weewiki_export_d *ex);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_export_txtmode(weewiki_export_d *ex)
{
    return ex->state.txtmode;
}
#+END_SRC
* Janet
Janet can be run as a standalone program with
=weewiki janet=. It is almost identical to the
vanilla janet program, except that the weewiki
functions are loaded as well.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "janet", 5)) {
    argc--;
    argv++;
    return p_janet(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_janet(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int janet_main(int argc, char *argv[]);
static int p_janet(int argc, char *argv[])
{
    return janet_main(argc, argv);
}
#+END_SRC
* Dump
Dumps all of the contents of a weewiki database into a
janet script. When the script is run with =weewiki janet=,
it will regenerate the database.

This is particularly useful for bootstrapping or updating
a database across multiple computers.

#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "dump", 4)) {
    argc--;
    argv++;
    return p_dump(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_dump(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_dump(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    int rc;
    const char *key, *value, *fname;
    sqlite3_stmt *stmt;
    FILE *fp;


    if (argc < 2) {
        fp = stdout;
    } else {
        fp = fopen(argv[1], "w");
        if (fp == NULL) {
            fprintf(stderr,
                    "Could not open '%s' for writing.\n",
                    argv[1]);
            return 1;
        }
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "SELECT wiki.key, wiki.value "
                       "FROM wiki LEFT JOIN wikilinks "
                       "ON wiki.key = wikilinks.key "
                       "WHERE wikilinks.key IS NULL;"
                       "FROM wikilinks;",
                       -1,
                       &stmt,
                       NULL);

    fprintf(fp, "# open and clear wiki db\n\n");
    fprintf(fp, "(ww-open \"a.db\")\n");
    fprintf(fp, "(ww-clear)\n");

    fprintf(fp, "\n# unlinked pages\n\n");

    while (1) {
        rc = sqlite3_step(stmt);
        if (rc != SQLITE_ROW) break;
        key = (const char *)sqlite3_column_text(stmt, 0);
        value = (const char *)sqlite3_column_text(stmt, 1);
        if (value == NULL) {
            fprintf(fp, "(ww-add-page \"%s\" \"\")\n", key);
        } else {
            fprintf(fp, "(ww-add-page \"%s\" `%s`)\n",
                    key, value);
        }
    }


    sqlite3_finalize(stmt);

    sqlite3_prepare_v2(db,
                       "SELECT key, filename "
                       "FROM wikilinks;",
                       -1,
                       &stmt,
                       NULL);

    fprintf(fp, "\n# linked lages\n\n");

    while (1) {
        rc = sqlite3_step(stmt);
        if (rc != SQLITE_ROW) break;
        key = (const char *)sqlite3_column_text(stmt, 0);
        fname = (const char *)sqlite3_column_text(stmt, 1);
        fprintf(fp, "(ww-add-link \"%s\" \"%s\")\n",
                key,
                fname);
    }


    sqlite3_finalize(stmt);

    fprintf(fp, "\n# sync and close\n\n");
    fprintf(fp, "(ww-sync)\n");
    fprintf(fp, "(ww-close)\n");

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return 0;
}
#+END_SRC
* Parse
The =parse= command will parse an org file via orgparse
and write the HTML output. This is primarily
useful for debugging scripts.
#+NAME: matching
#+BEGIN_SRC c
else if (match(argv[1], len, "parse", 5)) {
    argc--;
    argv++;
    return p_parse(argc, argv);
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_parse(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_parse(int argc, char *argv[])
{
    weewiki_d ww;
    FILE *fp;
    unsigned char *txt;
    size_t sz;
    weewiki_export_d ex;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s file.org\n", argv[0]);
        return 1;
    } else {
        fp = fopen(argv[1], "r");
        if (fp == NULL) {
            fprintf(stderr,
                    "Could not open '%s' for reading.\n",
                    argv[1]);
            return 1;
        }
    }

    weewiki_init(&ww);
    weewiki_open(&ww, "a.db");

    weewiki_set(&ww);

    weewiki_orgparse_setup(&ex.op);
    ex.env = weewiki_janet_setup();

    weewiki_janet_loadconfig(ex.env);

    ex.fp = stdout;
    ww.fp = ex.fp;
    ww.ex = &ex;

    fseek(fp, 0, SEEK_END);
    sz = ftell(fp);
    txt = calloc(1, sz + 1);
    fseek(fp, 0, SEEK_SET);
    fread(txt, 1, sz, fp);
    fclose(fp);

    write_file(&ex, txt, sz);

    weewiki_janet_cleanup();

    weewiki_close(&ww);
    weewiki_clean(&ww);

    return 0;
}
#+END_SRC
