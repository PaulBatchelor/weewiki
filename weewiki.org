#+TITLE: WeeWiki
* Overview
WeeWiki is a wee little personal wiki engine, with scripting
capabilities.
* Top Level Files
** C file
#+NAME: weewiki.c
#+BEGIN_SRC c :tangle weewiki.c
#include <stdlib.h>
#include <stdio.h>
#include <sqlite3.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>

#define ORGPARSE_IMPLEMENTATION
#include "orgparse.h"

#include "weewiki.h"
#include "weewiki_private.h"
#include "jan.h"
<<global_data>>
<<static_funcdefs>>
<<argparse>>
<<functions>>

int main(int argc, char *argv[])
{
    if (argc == 1) {
        argparse_print(stdout);
        return 1;
    }

    return argparse_match_and_run(argc, argv);
}
#+END_SRC
** Header Files
#+NAME: weewiki.h
#+BEGIN_SRC c :tangle weewiki.h
#ifndef WEEWIKI_H
#define WEEWIKI_H
#ifndef JANET_H_defined
#include <stdint.h>
typedef struct JanetTable JanetTable;
typedef struct Janet Janet;
int janet_dostring(JanetTable *env,
                   const uint8_t *bytes,
                   const char *sourcePath,
                   Janet *out);
int janet_dobytes(JanetTable *env,
                  const uint8_t *bytes,
                  int32_t len,
                  const char *sourcePath,
                  Janet *out);
#endif

<<typedefs>>
<<funcdefs>>
#endif
#+END_SRC
#+NAME: weewiki_private.h
#+BEGIN_SRC c :tangle weewiki_private.h
#ifndef WEEWIKI_PRIVATE_H
#define WEEWIKI_PRIVATE_H
<<structs>>
#endif
#+END_SRC
* Top Level Struct
** Struct Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct weewiki_d weewiki_d;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct weewiki_d {
    <<contents>>
};
#+END_SRC
** Contents
*** SQLite database
#+NAME: contents
#+BEGIN_SRC c
sqlite3 *db;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->db = NULL;
#+END_SRC
#+NAME: clean
#+BEGIN_SRC c
if (ww->db != NULL) {
    weewiki_close(ww);
}
#+END_SRC
The function =weewiki_db= will only be included if the
SQLite header is included as well. The janet interface for
instance, is not using this so why bother including it.

Well now. It would seem that the SQLITE3 header file that
ships with OSX uses the header guard =_SQLITE3_H_=. This was
causing some warnings to happen. Wonder which bright spark
at Apple decided *that* was a good idea.

So now, thanks to Apple, I have to complicate things and add
in some extra logic into what was already halfway to
becoming a bad idea.
#+NAME: funcdefs
#+BEGIN_SRC c
#if defined(SQLITE3_H) || defined(_SQLITE3_H_)
sqlite3* weewiki_db(weewiki_d *ww);
#endif
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
sqlite3* weewiki_db(weewiki_d *ww)
{
    return ww->db;
}
#+END_SRC
*** Global filehandle
#+NAME: contents
#+BEGIN_SRC c
FILE *fp;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->fp = stdout;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
FILE * weewiki_fp(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
FILE * weewiki_fp(weewiki_d *ww)
{
    if (ww == NULL) return stdout;
    else return ww->fp;
}
#+END_SRC
*** Global User Data
Used for the exporter org parser now, but will eventually be
utilized for the server parser.
#+NAME: contents
#+BEGIN_SRC c
void *ud;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->ud = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void * weewiki_ud(weewiki_d *ww);
void weewiki_ud_set(weewiki_d *ww, void *ud);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void * weewiki_ud(weewiki_d *ww)
{
    return ww->ud;
}

void weewiki_ud_set(weewiki_d *ww, void *ud)
{
    ww->ud = ud;
}
#+END_SRC
*** Global Parser Callback
Used in particular by Janet. Takes in weewiki data,
text, and text size.
#+NAME: contents
#+BEGIN_SRC c
void (*parse)(weewiki_d *, const char *, unsigned int);
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->parse = NULL;
#+END_SRC
Can be set using =weewiki_parse_set=.
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_parse_set(weewiki_d *ww,
                       void (*parse)(weewiki_d *,
                                     const char *,
                                     unsigned int));
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_parse_set(weewiki_d *ww,
                       void (*parse)(weewiki_d *,
                                     const char *,
                                     unsigned int))
{
    ww->parse = parse;
}
#+END_SRC
*** Global Printer Callback
This one is used anytime Janet wishes to print
something directly (usually HTML).
#+NAME: contents
#+BEGIN_SRC c
void (*print)(weewiki_d *, const char *, unsigned int);
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->print = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_print(weewiki_d *ww,
                   const char *str,
                   unsigned int sz);
void weewiki_print_set(weewiki_d *ww,
                       void (*print)(weewiki_d *,
                                     const char *,
                                     unsigned int));
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_print(weewiki_d *ww,
                   const char *str,
                   unsigned int sz)
{
    if (ww->print == NULL) {
        FILE *f;
        int i;
        f = ww->fp;
        for (i = 0; i < sz; ++i) {
            putc(str[i], f);
        }
        f = weewiki_fp(ww);
    } else {
        ww->print(ww, str, sz);
    }
}
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_print_set(weewiki_d *ww,
                       void (*print)(weewiki_d *,
                                     const char *,
                                     unsigned int))
{
    ww->print = print;
}
#+END_SRC
*** Global Page Name
Stores name of current page being parsed.
#+NAME: contents
#+BEGIN_SRC c
const char *name;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
ww->name = NULL;
#+END_SRC

Can be retrieved with =weewiki_pgname=.

#+NAME: funcdefs
#+BEGIN_SRC c
const char * weewiki_pgname(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
const char * weewiki_pgname(weewiki_d *ww)
{
    return ww->name;
}
#+END_SRC

Set it indirectly with =weewiki_pgname_set=.

#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_pgname_set(weewiki_d *ww, const char *name);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_pgname_set(weewiki_d *ww, const char *name)
{
    ww->name = name;
}
#+END_SRC
*** Server Flag
The variable =is_server= is a boolean variable used
to determine if weewiki is being used as a weewiki server
or not. 1 is true, 0 is false.

#+NAME: contents
#+BEGIN_SRC c
int is_server;
#+END_SRC

#+NAME: init
#+BEGIN_SRC c
weewiki_is_server_set(ww, 0);
#+END_SRC

It is false by default,
and can be set with =weewiki_is_server_set= and
the value is retrieved =weewiki_is_server=.

#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_is_server_set(weewiki_d *ww, int x);
int weewiki_is_server(weewiki_d *ww);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void weewiki_is_server_set(weewiki_d *ww, int is_server)
{
    ww->is_server = is_server;
}

int weewiki_is_server(weewiki_d *ww)
{
    return ww->is_server;
}
#+END_SRC
** Init
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_init(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_init(weewiki_d *ww)
{
    <<init>>
}
#+END_SRC
** Cleanup
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_clean(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_clean(weewiki_d *ww)
{
    <<clean>>
}
#+END_SRC
** Global Data Instance
To make integration with Janet easier, a global =weewiki_d=
pointer is used.

For the janet standalone, a global variable is set and used
by default.
#+NAME: global_data
#+BEGIN_SRC c
static weewiki_d iWeeWiki;
static weewiki_d *WeeWiki = &iWeeWiki;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_set(weewiki_d *ww);
weewiki_d *weewiki_get(void);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_set(weewiki_d *ww)
{
    WeeWiki = ww;
}

weewiki_d *weewiki_get(void)
{
    return WeeWiki;
}
#+END_SRC
** Struct Size
The struct size can be found with =weewiki_sizeof=. Useful
when dealing with weewiki as an opaque struct.

#+NAME: funcdefs
#+BEGIN_SRC c
unsigned long weewiki_sizeof(void);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
unsigned long weewiki_sizeof(void)
{
    return sizeof(weewiki_d);
}
#+END_SRC
* Argument Parsing
Based on constructs found in =worgmap=, a project found
in =worgle=.
** Argparse entry table
Every subcommand is stored inside of a table. This gets
dynamically populated with Worgle via a code block called
=orgparse_entries=.

#+NAME: argparse
#+BEGIN_SRC c
typedef struct {
    const char *name;
    int len;
    int (*fun)(int, char **);
    const char *desc;
} argparse_entry;

argparse_entry commands[] = {
    <<argparse_entries>>
};
#+END_SRC
** Argparse Run
The function =argparse_match_and_run= will attempt find and
run the proper subcommand. It will return the error code.
Any non-zero value will be considered an error.

This function assumes that =argc= is greater than 1. Do
checks beforehand.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int argparse_match_and_run(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int match(const char *s1,
                 int sz1,
                 const char *s2,
                 int sz2)
{
    return sz1 == sz2 && !strncmp(s1, s2, sz2);
}


static int argparse_match_and_run(int argc, char *argv[])
{
    size_t len;
    int rc;
    int nitems;
    int i;
    argparse_entry *cmd;

    rc = 0;

    nitems = sizeof(commands) / sizeof(*commands);

    len = strlen(argv[1]);

    cmd = commands;

    for (i = 0; i < nitems; i++) {
        if (match(argv[1], len, cmd[i].name, cmd[i].len)) {
            argc--;
            argv++;
            return cmd[i].fun(argc, argv);
        }
    }

    fprintf(stderr, "Could not find command '%s'\n", argv[1]);

    return rc;
}
#+END_SRC
** Print Arguments
Done with =argparse_print=.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static void argparse_print(FILE *fp);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static void argparse_print(FILE *fp)
{
    int nitems;
    int i;

    fprintf(fp, "Available commands:\n\n");
    nitems = sizeof(commands) / sizeof(*commands);

    for (i = 0; i < nitems; i++) {
        fprintf(fp, "%s\n", commands[i].name);
    }
}
#+END_SRC
* High Level Functions
Designed to be used inside Janet scripts.
** Add Page
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_add_page(weewiki_d *ww,
                      const char *key,
                      const char *val);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_add_page(weewiki_d *ww,
                      const char *key,
                      const char *val)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "INSERT INTO wiki"
                       "(key, value)\n"
                       "VALUES(?1, ?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, val, -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);
}
#+END_SRC
** Delete Page
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_del_page(weewiki_d *ww, const char *key);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void weewiki_del_page(weewiki_d *ww, const char *key)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "DELETE FROM wiki "
                       "WHERE (key ==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);
}
#+END_SRC
** Link Page
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_add_link(weewiki_d *ww,
                      const char *key,
                      const char *fname);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_add_link(weewiki_d *ww,
                      const char *key,
                      const char *fname)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "INSERT INTO wikilinks"
                       "(key, filename)\n"
                       "VALUES(?1, ?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, fname, -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);
}
#+END_SRC
** Sync
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_sync(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void update_mtime(weewiki_d *ww,
                         const char *fname,
                         const char *key)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    struct stat st;
    unsigned int mtime;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "UPDATE wikilinks SET mtime=?1 "
                       "WHERE (key==?2);",
                       -1,
                       &stmt,
                       NULL);

    stat(fname, &st);
    mtime = st.st_mtime;

    sqlite3_bind_int(stmt, 1, mtime);
    sqlite3_bind_text(stmt, 2, key, -1, NULL);

    sqlite3_step(stmt);
    sqlite3_finalize(stmt);
}

static int sync_file(weewiki_d *ww, sqlite3_stmt *stmt)
{
    int rc;
    const char *fname;
    const char *key;
    unsigned int int_mtime;
    unsigned int ext_mtime;
    struct stat st;

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) return 0;
    key = (const char *)sqlite3_column_text(stmt, 0);
    fname = (const char *)sqlite3_column_text(stmt, 1);
    int_mtime = sqlite3_column_int(stmt, 2);

    if (access(fname, F_OK) == -1) {
        ext_mtime = 0;
    } else {
        stat(fname, &st);
        ext_mtime = st.st_mtime;
    }

    if (int_mtime == ext_mtime) {
        printf("SKIP %s\n", key);
    } else if (ext_mtime > int_mtime) {
        printf("PUSH %s %s\n", fname, key);
        weewiki_push(ww, fname, key);
        update_mtime(ww, fname, key);
    } else if (int_mtime > ext_mtime) {
        printf("PULL %s %s\n", key, fname);
        weewiki_pull(ww, key, fname);
    }

    return 1;
}

int weewiki_sync(weewiki_d *ww)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = 0;
    db = ww->db;

    sqlite3_prepare_v2(db,
                       "SELECT key, filename, mtime "
                       "FROM wikilinks;",
                       -1,
                       &stmt,
                       NULL);

    while (1) {
        if (!sync_file(ww, stmt)) {
            break;
        }
    }

    sqlite3_finalize(stmt);
    return rc;
}
#+END_SRC
** Clear
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_clear(weewiki_d *ww);
#+END_SRC

When working with a massive zet, I began noticing that my
SQLite database was getting larger and larger, even after
I removed all tables. This is because tables are marked
for removal, but aren't necessarily removed.

The solution to this is: =VACUUM=.

#+NAME: functions
#+BEGIN_SRC c
void weewiki_clear(weewiki_d *ww)
{
    sqlite3_exec(ww->db, "BEGIN;\n", NULL, NULL, NULL);
    sqlite3_exec(ww->db,
                "DELETE FROM wiki WHERE 1;\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db,
                "DELETE FROM wikilinks WHERE 1;\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db,
                "DELETE FROM wikizet WHERE 1;\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db,
                "VACUUM;\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db, "COMMIT;\n", NULL, NULL, NULL);
}
#+END_SRC
** Parsing
See the Export section. That's where all the action
is happening related to orgparse.
* Database
** Open
A database is opened with =weewiki_open=.
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_open(weewiki_d *ww, const char *filename);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_open(weewiki_d *ww, const char *filename)
{
    sqlite3 *db;
    int rc;
    FILE *fp;


    fp = fopen(filename, "r");

    if (fp == NULL) {
        fprintf(stderr,
            "Could not find database %s\n",
            filename);
        return 1;
    }

    fclose(fp);

    ww->db = NULL;
    rc = sqlite3_open(filename, &db);

    if (rc) {
        fprintf(stderr,
                "Could not open database: %s",
                sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    ww->db = db;
    return 0;
}
#+END_SRC
** Create
Creates and initializes a weewiki database.

#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_create(weewiki_d *ww, const char *filename);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int weewiki_create(weewiki_d *ww, const char *filename)
{
    sqlite3 *db;
    int rc;

    ww->db = NULL;
    rc = sqlite3_open(filename, &db);

    if (rc) {
        fprintf(stderr,
                "Could not open database: %s",
                sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    ww->db = db;
    weewiki_create_tables(ww);
    return 0;
}
#+END_SRC
** Close
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_close(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_close(weewiki_d *ww)
{
    if (ww->db != NULL) sqlite3_close(ww->db);
    ww->db = NULL;
}
#+END_SRC
** Get
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_getter(weewiki_d *ww, const char *key);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_getter(weewiki_d *ww, const char *key)
{
    size_t sz;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    FILE *fp;

    fp = stdout;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT value FROM wiki WHERE(key==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr,
                "Could not find key '%s'\n",
                key);
        sqlite3_finalize(stmt);
        return 1;
    }

    sz = sqlite3_column_bytes(stmt, 0);
    fwrite(sqlite3_column_text(stmt, 0), 1, sz, fp);
    sqlite3_finalize(stmt);
    return 0;
}
#+END_SRC
** Set
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_setter(weewiki_d *ww,
                   const char *key,
                   const char *val);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_setter(weewiki_d *ww,
                   const char *key,
                   const char *val)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT value FROM wiki WHERE(key==?1);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_prepare_v2(db,
                       "INSERT OR REPLACE INTO wiki"
                       "(key, value)\n"
                       "VALUES(?1,?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, val, -1, NULL);

    sqlite3_step(stmt);

    sqlite3_finalize(stmt);
    return 0;
}
#+END_SRC
** Create Tables
The function =weewiki_create_tables= creates all the needed
SQLite tables needed by weewiki. This includes =wiki=,
=wikilinks=, and =wikizet=.

The =wiki= table is most important table by weewiki. It
holds all the wiki document content. wikis are stored in
a key-value fashion, with unique keys being the page names,
and =text= being the page content, stored in org markup.

The =wikilinks= table is used to managed all externally
linked files. What is given here is the page name
(the =key=), the filename path, and the unix modification
time =mtime=. This logic is used to determine syncing.

The =wikizet= table is the the weewiki zettelkasten
interface. It is implemented using SQLites full-text
search capabilities (fts5) as a virtual table. Similar to
the wiki, the zet is a key/value database, except that
the keys are UUIDs that do not have a unique constraint, and
each entry has an optional timestamp for microblogging.

#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_create_tables(weewiki_d *ww);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_create_tables(weewiki_d *ww)
{
    sqlite3_exec(ww->db,
                "CREATE TABLE IF NOT EXISTS wiki(\n"
                "key TEXT UNIQUE,\n"
                "value TEXT\n"
                ");\n",
                NULL,
                NULL,
                NULL);
    sqlite3_exec(ww->db,
                "CREATE TABLE IF NOT EXISTS wikilinks(\n"
                "key TEXT UNIQUE,\n"
                "filename TEXT,\n"
                "mtime INTEGER\n"
                ");\n",
                NULL,
                NULL,
                NULL);

    sqlite3_exec(ww->db,
                 "CREATE VIRTUAL TABLE wikizet using fts5("
                 "time,\n"
                 "UUID,\n"
                 "value);\n",
                 NULL,
                 NULL,
                 NULL);
}
#+END_SRC
** Push
Low level operation that pushes a file to a key. On error,
returns a non-zero value.

#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_push(weewiki_d *ww,
                 const char *fname,
                 const char *key);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_push(weewiki_d *ww,
                 const char *fname,
                 const char *key)
{
    char *buf;
    size_t sz;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    FILE *fp;

    fp = fopen(fname, "r");

    if (fp == NULL) {
        fprintf(stderr,
                "Could not open file %s for reading.\n",
                fname);
        return 1;
    }

    fseek(fp, 0, SEEK_END);
    sz = ftell(fp);
    buf = calloc(1, sz + 1);
    fseek(fp, 0, SEEK_SET);
    fread(buf, 1, sz, fp);

    db = ww->db;

    sqlite3_prepare_v2(db,
                       "INSERT OR REPLACE INTO wiki"
                       "(key, value)\n"
                       "VALUES(?1,?2);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, key, -1, NULL);
    sqlite3_bind_text(stmt, 2, buf, sz, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr,
                "SQLite error: %s\n",
                sqlite3_errmsg(db));
         return 1;
    }
    sqlite3_finalize(stmt);

    free(buf);
    return 0;
}
#+END_SRC
** Pull
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_pull(weewiki_d *ww,
                 const char *key,
                 const char *fname);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int weewiki_pull(weewiki_d *ww,
                 const char *key,
                 const char *fname)
{
    size_t sz;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    FILE *fp;

    fp = fopen(fname, "w");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not open file %s for writing\n",
                fname);
        return 1;
    }

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT value FROM wiki WHERE(key==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);

    rc = sqlite3_step(stmt);

    if (rc != SQLITE_ROW) {
        fprintf(stderr,
                "Could not find key '%s'\n",
                key);
        sqlite3_finalize(stmt);
        return 1;
    }

    sz = sqlite3_column_bytes(stmt, 0);
    fwrite(sqlite3_column_text(stmt, 0), 1, sz, fp);
    sqlite3_finalize(stmt);
    fclose(fp);
    return 0;
}
#+END_SRC
** Exists
The function =weewiki_exists= is used to check if
a page (=key=) exists in the weewiki database. Returns
TRUE (1) or FALSE (0).

#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_exists(weewiki_d *ww, const char *key);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int weewiki_exists(weewiki_d *ww, const char *key)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = ww->db;
    sqlite3_prepare_v2(db,
                       "SELECT EXISTS("
                       "SELECT * FROM wiki WHERE(key==?1)"
                       ");",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, key, -1, NULL);

    sqlite3_step(stmt);

    rc = sqlite3_column_int(stmt, 0);

    sqlite3_finalize(stmt);
    return rc;
}
#+END_SRC
** Name Set/Get
Sets/gets the database name.

A global variable is used outside of the global =weewiki_d=
because it needs to be able to be set before that struct
is initialized.

#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_dbname_set(const char *name);
const char * weewiki_dbname_get(void);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static const char *g_dbname = "a.db";
void weewiki_dbname_set(const char *name)
{
    g_dbname = name;
}

const char * weewiki_dbname_get(void)
{
    return g_dbname;
}
#+END_SRC
* Create
=create= creates a weewiki database in the currently
directory. By default, this is called "a.db".

#+NAME: argparse_entries
#+BEGIN_SRC c
{"create", 6, p_create, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_create(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_create(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;
    const char *dbname;

    if (argc > 1) {
        dbname = argv[1];
    } else {
        dbname = weewiki_dbname_get();
    }

    weewiki_init(&ww);

    rc = weewiki_create(&ww, dbname);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC

* Push/Pull
** Push
Pushes a file to database.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"push", 4, p_push, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_push(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_push(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s file key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    rc = weewiki_push(&ww, argv[1], argv[2]);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** Pull
#+NAME: argparse_entries
#+BEGIN_SRC c
{"pull", 4, p_pull, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_pull(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int p_pull(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s file key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    rc = weewiki_pull(&ww, argv[1], argv[2]);
    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Edit
#+NAME: argparse_entries
#+BEGIN_SRC c
{"edit", 4, p_edit, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_edit(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_edit(int argc, char *argv[])
{
    weewiki_d ww;
    char fname[128];
    char cmd[256];
    struct tm tm;
    time_t t;
    FILE *fp;

    t = time(NULL);
    tm = *localtime(&t);

    strftime(fname, 128128, "tmp_%m%d%y%H%M%S.org", &tm);
    fprintf(stderr, "tmpname is %s\n", fname);

    if (argc < 2) {
        fprintf(stderr,
                "Usage: %s key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    if (weewiki_exists(&ww, argv[1])) {
        fprintf(stderr, "pulling %s to %s\n", argv[1], fname);
        weewiki_pull(&ww, argv[1], fname);
    } else {
        fp = fopen(fname, "w");
        fprintf(fp, "A new page.");
        fclose(fp);
    }

    sprintf(cmd, "$EDITOR %s", fname);
    system(cmd);
    weewiki_push(&ww, fname, argv[1]);
    weewiki_close(&ww);
    weewiki_clean(&ww);
    remove(fname);
    return 1;
}
#+END_SRC
* ls
List all pages.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"ls", 2, p_ls, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_ls(int argc, char *argv[]);
#+END_SRC

You'll notice some duplicate code here. This has been
introduced because of a change in behavior. The last
parameter of "ls" can now specify the databse file name in
place of "a.db". Because there are a variable number of
arguments, there are a few permutations:

No arguments will invoke the default ls behavior with
"a.db".

If there is one argument, it will either be "links", or
a database name. "links" will list all the linked pages
using "a.db". Any other value will invoke the default ls
behavior using that as the database file name.

Three arguments will invoke "ls links" with a custom
database filename. If the second argument is not "links",
it will return an error.

The duplicate code is done for the sake of readability, and
is used to make the edge cases above more clear-cut.
#+NAME: functions
#+BEGIN_SRC c
static int list(void *ud, int sz, char **argv, char **col)
{
    int n;
    for(n = 0; n < sz; n++) {
        if (n != 0) printf(" ");
        printf("%s", argv[n]);
    }
    printf("\n");
    return 0;
}

static int p_ls(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    weewiki_init(&ww);

    rc = 0;

    if (argc == 1) {
        weewiki_open(&ww, weewiki_dbname_get());
        sqlite3_exec(ww.db,
                    "SELECT key FROM wiki;",
                    list,
                    NULL,
                    NULL);
    } else if (argc == 2) {
        if (!strcmp(argv[1], "links")) {
            weewiki_open(&ww, weewiki_dbname_get());
            sqlite3_exec(ww.db,
                        "SELECT key, filename FROM wikilinks;",
                        list,
                        NULL,
                        NULL);
        } else {
            weewiki_open(&ww, argv[1]);
            sqlite3_exec(ww.db,
                        "SELECT key FROM wiki;",
                        list,
                        NULL,
                        NULL);
        }
    } else if (argc == 3) {
        if (!strcmp(argv[1], "links")) {
            weewiki_open(&ww, argv[2]);
            sqlite3_exec(ww.db,
                        "SELECT key, filename FROM wikilinks;",
                        list,
                        NULL,
                        NULL);
        } else {
            fprintf(stderr, "Invalid command '%s'\n",
                    argv[1]);
            fprintf(stderr, "Expected 'links'.\n");
            rc = 1;
        }
    }

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Link
The "link" operation will link a page to a filepath.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"link", 4, p_link, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_link(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_link(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    struct stat st;
    int force;

    force = 0;
    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s key file [db]\n",
                argv[0]);
        return 1;
    }

    if (argc > 1  && !strcmp(argv[1], "-f")) {
        force = 1;
        argv++;
        argc--;
    }

    if (!force) {
        if (access(argv[2], F_OK) != -1) {
            fprintf(stderr, "%s: file exists.\n", argv[2]);
            return 1;
        }
    }

    weewiki_init(&ww);

    if (argc >= 4) {
        weewiki_open(&ww, argv[3]);
    } else {
        weewiki_open(&ww, weewiki_dbname_get());
    }

    if (force) {
        rc = weewiki_push(&ww, argv[2], argv[1]);
    } else {
        rc = weewiki_pull(&ww, argv[1], argv[2]);
    }

    if (rc) goto cleanup;

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "INSERT OR REPLACE INTO wikilinks"
                       "(key, filename, mtime)\n"
                       "VALUES(?1,?2,?3);",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    sqlite3_bind_text(stmt, 2, argv[2], -1, NULL);
    stat(argv[2], &st);
    sqlite3_bind_int(stmt, 3, st.st_mtime);

    sqlite3_step(stmt);

    sqlite3_finalize(stmt);

    cleanup:
    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Sync
The =sync= command is used to sync files between the
database and external files. It will iterate through the
=wikilinks= tables and update things by comparing internal
modification times.

If the external mtime is greater, the file is pushed to the
table.

If the internal mtime is greater, the file is pulled from
table.

If the times are equal, no action happens.

If the external file doesn't exist, it is treated as a
"pull" operation.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"sync", 4, p_sync, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_sync(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_sync(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    weewiki_init(&ww);

    if (argc == 2) {
        weewiki_open(&ww, argv[1]);
    } else {
        weewiki_open(&ww, weewiki_dbname_get());
    }

    rc = weewiki_sync(&ww);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Add/Remove Page
Adds/removes a new page.
** add
#+NAME: argparse_entries
#+BEGIN_SRC c
{"add", 3, p_add, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_add(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_add(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = 0;
    if (argc < 2) {
        fprintf(stderr,
                "Usage: %s key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "INSERT INTO wiki"
                       "(key)\n"
                       "VALUES(?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** del
#+NAME: argparse_entries
#+BEGIN_SRC c
{"del", 3, p_del, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_del(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_del(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = 0;
    if (argc < 2) {
        fprintf(stderr,
                "Usage: %s key\n",
                argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "DELETE FROM wiki "
                       "WHERE (key ==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);

    sqlite3_prepare_v2(db,
                       "DELETE FROM wikilinks "
                       "WHERE (key ==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, argv[1], -1, NULL);
    rc = sqlite3_step(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = 1;
    }

    sqlite3_finalize(stmt);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
* Export
** Command
#+NAME: argparse_entries
#+BEGIN_SRC c
{"export", 6, p_export, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_export(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_export(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;
    weewiki_export_d ex;
    sqlite3 *db;
    const unsigned char *dir;
    int export_page;

    if (argc < 2) {
        export_page = 0;
    } else {
        export_page = 1;
    }

    rc = 0;

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    if (!rc) {
        db = ww.db;
        weewiki_set(&ww);

        weewiki_orgparse_setup(&ex.op);
        ex.env = weewiki_janet_setup();

        weewiki_janet_loadconfig(ex.env);
        dir = weewiki_janet_wwdir(ex.env);

        if (export_page) {
            write_single_file(&ww, &ex, db, dir, argv[1]);
        } else {
            write_multiple_files(&ww, &ex, db, dir);
        }

        weewiki_janet_cleanup();
    }

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return rc;
}
#+END_SRC
** Orgparse Export Struct
This is a struct passed into orgparse.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct weewiki_export_d weewiki_export_d;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct weewiki_export_d {
    weewiki_d *ww;
    FILE *fp;
    orgparse op;
    JanetTable *env;
    orgparse_state state;
};
#+END_SRC
** Orgparse callback setup
Orgparse is used to parse a text buffer and generate HTML
content. To do this, a series of callbacks are implemented.

=weewiki_orgparse_setup= is enclosed in a ifdef macro
for =ORGPARSE_H=. This is done so that =orgparse.h= need
not be explicitely included if it not needed.

Honestly, this sort of practice a slippery slope, but
in moderation it is quite convenient.

#+NAME: funcdefs
#+BEGIN_SRC c
#ifdef ORGPARSE_H /* define if orgparse header included */
void weewiki_orgparse_setup(orgparse *op);
#endif
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
<<orgparse_callbacks>>
void weewiki_orgparse_setup(orgparse *op)
{
    orgparse_init(op);
    <<orgparse_html_setup>>
}
#+END_SRC
*** Header
Since =h1= is only reserved for titles, make all
the header sizes one level smaller.
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_header(void *ud,
                        const char *h,
                        size_t sz,
                        int lvl)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    lvl++;
    fprintf(fp, "\n<h%d>", lvl);
    fwrite(h, 1, sz, fp);
    fprintf(fp, "</h%d>\n\n", lvl);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_header(op, html_header);
#+END_SRC
*** Text
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_text(void *ud,
                      const char *str,
                      size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fwrite(str, 1, sz, fp);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_text(op, html_text);
#+END_SRC
*** Bold
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_bold(void *ud,
                      const char *str,
                      size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<b>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</b>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_bold(op, html_bold);
#+END_SRC
*** Aux
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_aux(void *ud,
                     const char *str,
                     size_t sz)
{
    weewiki_export_d *ex;
    ex = ud;
    janet_dobytes(ex->env,
                  (const uint8_t *)str, sz,
                  NULL, NULL);
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_aux(op, html_aux);
#+END_SRC
*** Newline
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_newline(void *ud,
                         const char *str,
                         size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<br>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_newline(op, html_newline);
#+END_SRC
*** Code
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_code(void *ud,
                      const char *str,
                      size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<code>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</code>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_code(op, html_code);
#+END_SRC
*** Code Block
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_codeblock(void *ud,
                           const char *str,
                           size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    size_t n;
    ex = ud;
    fp = ex->fp;

    fprintf(fp, "<pre><code>");
    for (n = 0; n < sz; n++) {
        switch (str[n]) {
            case '<':
                fprintf(fp, "&lt;");
                break;
            case '>':
                fprintf(fp, "&gt;");
                break;
            default:
                fputc(str[n], fp);
                break;
        }
    }
    fprintf(fp, "</pre></code>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_codeblock(op, html_codeblock);
#+END_SRC
*** Name
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_name(void *ud,
                      const char *str,
                      size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;

    fprintf(fp, "<div><b><i>&lt;&lt;");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "&gt;&gt;=</i></b></div>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_name(op, html_name);
#+END_SRC
*** Title
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_title(void *ud,
                           const char *str,
                           size_t sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<title>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</title>\n");
    fprintf(fp, "<h1>");
    fwrite(str, 1, sz, fp);
    fprintf(fp, "</h1>\n");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_title(op, html_title);
#+END_SRC
*** Link
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_link(void *ud,
                      const char *link,
                      size_t link_sz,
                      const char *name,
                      size_t name_sz)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;
    fprintf(fp, "<a href=\"");
    fwrite(link, 1, link_sz, fp);
    fprintf(fp, "\">");
    fwrite(name, 1, name_sz, fp);
    fprintf(fp, "</a>");
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_link(op, html_link);
#+END_SRC
*** Paragraph
#+NAME: orgparse_callbacks
#+BEGIN_SRC c
static void html_pgrph(void *ud, int mode)
{
    weewiki_export_d *ex;
    FILE *fp;
    ex = ud;
    fp = ex->fp;

    if (mode) {
        fprintf(fp, "</p>\n");
    } else {
        fprintf(fp, "<p>");
    }
}
#+END_SRC
#+NAME: orgparse_html_setup
#+BEGIN_SRC c
orgparse_set_pgrph(op, html_pgrph);
#+END_SRC
** Run
#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_export_run(weewiki_export_d *ex,
                        const char *buf,
                        size_t sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_export_run(weewiki_export_d *ex,
                        const char *buf,
                        size_t sz)
{
    orgparse_state_init(&ex->state, &ex->op, buf, sz, ex);
    orgparse_state_run(&ex->state);
}
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_export_continue(weewiki_export_d *ex,
                             const char *buf,
                             size_t sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void weewiki_export_continue(weewiki_export_d *ex,
                             const char *buf,
                             size_t sz)
{
    orgparse_state_flags *f;
    orgparse_state state;
    orgparse_state_init(&state, &ex->op, buf, sz, ex);
    f = orgparse_state_flags_get(&ex->state);
    orgparse_state_flags_set(&state, f);
    orgparse_state_run(&state);
}
#+END_SRC
** Write File
This generates a file
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void write_file(weewiki_export_d *ex,
                       const unsigned char *txt,
                       size_t txt_sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void write_file(weewiki_export_d *ex,
                       const unsigned char *txt,
                       size_t txt_sz)
{
    janet_dostring(ex->env,
                   (const unsigned char *)"(html-header)",
                   NULL, NULL);
    weewiki_export_run(ex, (const char *)txt, txt_sz);
    orgparse_end(&ex->op, ex, &ex->state);
    janet_dostring(ex->env,
                   (const unsigned char *)"(html-footer)",
                   NULL, NULL);
}
#+END_SRC
** Make Filehandle
Generates a filehandle. If null values are passed in,
return =stdout=.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static FILE * mkfile(const unsigned char *dir,
                     const unsigned char *name);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static FILE * mkfile(const unsigned char *dir,
                     const unsigned char *name)
{
    FILE *fp;
    char tmp[256];
    if (name == NULL) return stdout;

    if(!strcmp((const char *)name, "index")) {
        sprintf(tmp, "%s/index.html", dir);
    } else {
        getcwd(tmp, 256);
        chdir((const char *)dir);
        mkdir((const char*)name, 0755);
        chdir(tmp);
        sprintf(tmp, "%s/%s/index.html", dir, name);
    }
    fp = fopen(tmp, "w");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not write to file %s\n",
                tmp);
    }
    return fp;
}
#+END_SRC
** Write Single File
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void write_single_file(weewiki_d *ww,
                              weewiki_export_d *ex,
                              sqlite3 *db,
                              const unsigned char *dir,
                              const char *name);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void write_single_file(weewiki_d *ww,
                              weewiki_export_d *ex,
                              sqlite3 *db,
                              const unsigned char *dir,
                              const char *name)
{
    sqlite3_stmt *stmt;

    if (!weewiki_exists(ww, name)) {
        fprintf(stderr,
                "Could not find page '%s'\n",
                name);
        return;
    }

    sqlite3_prepare_v2(db,
                        "SELECT value "
                        "FROM wiki WHERE (key==?1);",
                        -1,
                        &stmt,
                        NULL);

    sqlite3_bind_text(stmt, 1, name, -1, NULL);
    sqlite3_step(stmt);

    ex->fp = mkfile(dir, NULL);
    ww->fp = ex->fp;
    ww->ud = ex;
    ww->name = name;

    write_file(ex,
               sqlite3_column_text(stmt, 0),
               sqlite3_column_bytes(stmt, 0));

    sqlite3_finalize(stmt);
}
#+END_SRC
** Write Multiple Files
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void write_multiple_files(weewiki_d *ww,
                                 weewiki_export_d *ex,
                                 sqlite3 *db,
                                 const unsigned char *dir);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void write_multiple_files(weewiki_d *ww,
                                 weewiki_export_d *ex,
                                 sqlite3 *db,
                                 const unsigned char *dir)
{
    sqlite3_stmt *stmt;
    int rc;
    const unsigned char *key;

    sqlite3_prepare_v2(db,
                        "SELECT key, value "
                        "FROM wiki "
                        "WHERE key NOT LIKE \"@%\";",
                        -1,
                        &stmt,
                        NULL);

    rc = sqlite3_step(stmt);

    while (rc == SQLITE_ROW) {
        key = sqlite3_column_text(stmt, 0);
        ex->fp = mkfile(dir,
                        sqlite3_column_text(stmt, 0));
        ww->fp = ex->fp;
        ww->ud = ex;
        ww->name = (const char *)key;
        if (ex->fp != NULL) {
            fprintf(stdout, "Writing %s\n", key);
            write_file(ex,
                    sqlite3_column_text(stmt, 1),
                    sqlite3_column_bytes(stmt, 1));
            fclose(ex->fp);
        } else {
            break;
        }
        rc = sqlite3_step(stmt);
    }


    sqlite3_finalize(stmt);
}
#+END_SRC
** Parsing In Janet
With the addition of the weewiki server, there is a growing
need make the Janet functions more flexible. In particular
the =org= function, which may or may not use the
=weewiki_export_d= data.

The function =weewiki_janet_org= is a generic function
called by the =cfun_org= function that only requires
the weewiki data (exposed as a global variable), the
text to be parsed, and the length of that text.

#+NAME: funcdefs
#+BEGIN_SRC c
void weewiki_janet_org(weewiki_d *ww,
                       const char *txt,
                       unsigned int len);
#+END_SRC
By default, this just calls =weewiki_export_continue=,
otherwise, it calls the custom callback.
#+NAME: functions
#+BEGIN_SRC c
void weewiki_janet_org(weewiki_d *ww,
                       const char *txt,
                       unsigned int len)
{

    if (ww->parse == NULL) {
        weewiki_export_d *ex;
        ex = ww->ud;
        weewiki_export_continue(ex, txt, len);
    } else {
        ww->parse(ww, txt, len);
    }
}
#+END_SRC
* Janet
Janet can be run as a standalone program with
=weewiki janet=. It is almost identical to the
vanilla janet program, except that the weewiki
functions are loaded as well.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"janet", 5, p_janet, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_janet(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int janet_main(int argc, char *argv[]);
static int p_janet(int argc, char *argv[])
{
    return janet_main(argc, argv);
}
#+END_SRC
* Dump
Dumps all of the contents of a weewiki database into a
janet script. When the script is run with =weewiki janet=,
it will regenerate the database.

This is particularly useful for bootstrapping or updating
a database across multiple computers.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"dump", 4, p_dump, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_dump(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_dump(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;
    int rc;
    const char *key, *value, *fname;
    sqlite3_stmt *stmt;
    FILE *fp;

    if (argc < 2) {
        fp = stdout;
    } else {
        fp = fopen(argv[1], "w");
        if (fp == NULL) {
            fprintf(stderr,
                    "Could not open '%s' for writing.\n",
                    argv[1]);
            return 1;
        }
    }

    weewiki_init(&ww);
    if (argc >= 3) {
        weewiki_open(&ww, argv[2]);
    } else {
        weewiki_open(&ww, weewiki_dbname_get());
    }

    db = ww.db;

    sqlite3_prepare_v2(db,
                       "SELECT wiki.key, wiki.value "
                       "FROM wiki LEFT JOIN wikilinks "
                       "ON wiki.key = wikilinks.key "
                       "WHERE wikilinks.key IS NULL;"
                       "FROM wikilinks;",
                       -1,
                       &stmt,
                       NULL);

    fprintf(fp, "# open and clear wiki db\n\n");
    /* TODO: add ww-dbname-get janet word */
    fprintf(fp, "(ww-open \"a.db\")\n");
    fprintf(fp, "(ww-clear)\n");

    fprintf(fp, "\n# unlinked pages\n\n");

    while (1) {
        rc = sqlite3_step(stmt);
        if (rc != SQLITE_ROW) break;
        key = (const char *)sqlite3_column_text(stmt, 0);
        value = (const char *)sqlite3_column_text(stmt, 1);
        if (value == NULL) {
            fprintf(fp, "(ww-add-page \"%s\" \"\")\n", key);
        } else {
            fprintf(fp, "(ww-add-page \"%s\" `%s`)\n",
                    key, value);
        }
    }


    sqlite3_finalize(stmt);

    sqlite3_prepare_v2(db,
                       "SELECT key, filename "
                       "FROM wikilinks;",
                       -1,
                       &stmt,
                       NULL);

    fprintf(fp, "\n# linked pages\n\n");

    while (1) {
        rc = sqlite3_step(stmt);
        if (rc != SQLITE_ROW) break;
        key = (const char *)sqlite3_column_text(stmt, 0);
        fname = (const char *)sqlite3_column_text(stmt, 1);
        fprintf(fp, "(ww-add-link \"%s\" \"%s\")\n",
                key,
                fname);
    }


    sqlite3_finalize(stmt);

    fprintf(fp, "\n# sync and close\n\n");
    fprintf(fp, "(ww-sync)\n");
    fprintf(fp, "(ww-close)\n");

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return 0;
}
#+END_SRC
* Parse
The =parse= command will parse an org file via orgparse
and write the HTML output. This is primarily
useful for debugging scripts.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"parse", 5, p_parse, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_parse(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_parse(int argc, char *argv[])
{
    weewiki_d ww;
    FILE *fp;
    unsigned char *txt;
    size_t sz;
    weewiki_export_d ex;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s file.org\n", argv[0]);
        return 1;
    } else {
        fp = fopen(argv[1], "r");
        if (fp == NULL) {
            fprintf(stderr,
                    "Could not open '%s' for reading.\n",
                    argv[1]);
            return 1;
        }
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    weewiki_set(&ww);

    weewiki_orgparse_setup(&ex.op);
    ex.env = weewiki_janet_setup();

    weewiki_janet_loadconfig(ex.env);

    ex.fp = stdout;
    ww.fp = ex.fp;
    ww.ud = &ex;

    fseek(fp, 0, SEEK_END);
    sz = ftell(fp);
    txt = calloc(1, sz + 1);
    fseek(fp, 0, SEEK_SET);
    fread(txt, 1, sz, fp);
    fclose(fp);

    write_file(&ex, txt, sz);

    weewiki_janet_cleanup();

    weewiki_close(&ww);
    weewiki_clean(&ww);

    return 0;
}
#+END_SRC
* Get
Gets a page and prints it to standard output.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"get", 3, p_get, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_get(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_get(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s page\n", argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    rc = weewiki_getter(&ww, argv[1]);

    weewiki_close(&ww);
    weewiki_clean(&ww);

    return rc;
}
#+END_SRC
* Set
Gets a page and prints it to standard output.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"set", 3, p_set, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_set(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_set(int argc, char *argv[])
{
    weewiki_d ww;
    int rc;

    if (argc < 3) {
        fprintf(stderr, "Usage: %s page value\n", argv[0]);
        return 1;
    }

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    rc = weewiki_setter(&ww, argv[1], argv[2]);

    weewiki_close(&ww);
    weewiki_clean(&ww);

    return rc;
}
#+END_SRC
* Server
Will instantiate a local http server on port 8080 by
default. Only enabled if =WWSERVER= is defined.

#+NAME: static_funcdefs
#+BEGIN_SRC c
int weewiki_server(weewiki_d *ww, int argc, char *argv[]);
#+END_SRC

#+NAME: argparse_entries
#+BEGIN_SRC c
{"server", 6, p_server, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
#ifdef WWSERVER
static int p_server(int argc, char *argv[]);
#endif
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
#ifdef WWSERVER
static int p_server(int argc, char *argv[])
{
    weewiki_d ww;
    return weewiki_server(&ww, argc, argv);
}
#endif
#+END_SRC
* JPM
Runs a local instance of JPM.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"jpm", 3, p_jpm, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_jpm(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int weewiki_jpm(int argc, char *argv[]);
static int p_jpm(int argc, char *argv[])
{
    return weewiki_jpm(argc, argv);
}
#+END_SRC
* Keyscrape
Scrapes keywords for a given page. If no page
is given, it scrapes all pages. The output is written
to =stdout= as a list of comma-separated values (CSV).

#+NAME: argparse_entries
#+BEGIN_SRC c
{"keyscrape", 9, p_keyscrape, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_keyscrape(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int ww_keyscrape(int argc, char *argv[]);
static int p_keyscrape(int argc, char *argv[])
{
    return ww_keyscrape(argc, argv);
}
#+END_SRC
* Zet
Zet is the weewiki zettelkasten. This is the entry point
for the zet command-line interface.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"zet", 3, p_zet, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_zet(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int ww_zet(int argc, char *argv[]);
static int p_zet(int argc, char *argv[])
{
    return ww_zet(argc, argv);
}
#+END_SRC
* Crate
The =crate= is a interface that connects the SQLar
format to the weewiki zettelkasten.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"crate", 5, p_crate, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_crate(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int ww_crate(int argc, char *argv[]);
static int p_crate(int argc, char *argv[])
{
    return ww_crate(argc, argv);
}
#+END_SRC
* Vacuum
#+NAME: argparse_entries
#+BEGIN_SRC c
{"vacuum", 6, p_vacuum, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_vacuum(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_vacuum(int argc, char *argv[])
{
    weewiki_d ww;
    sqlite3 *db;

    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    db = weewiki_db(&ww);
    sqlite3_exec(db, "VACUUM;\n", NULL, NULL, NULL);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return 0;
}
#+END_SRC
* Clear
Clears a weewiki database.

#+NAME: argparse_entries
#+BEGIN_SRC c
{"clear", 5, p_clear, NULL},
#+END_SRC

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int p_clear(int argc, char *argv[]);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int p_clear(int argc, char *argv[])
{
    weewiki_d ww;
    weewiki_init(&ww);
    weewiki_open(&ww, weewiki_dbname_get());

    weewiki_clear(&ww);

    weewiki_close(&ww);
    weewiki_clean(&ww);
    return 0;
}
#+END_SRC
