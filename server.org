#+TODO: TODO(t) WIP(w@/!) | DONE(d!)
#+TITLE: WeeWiki Server
A work in progress. Rambles for now. No code.

This document aims to implement a local http server around
weewiki. Instead of statically generating HTML,
pages are dynamically generated.

The single-header =httpserver.h= program by jeremycw will be
http server implementation.
* Top Files
The top level files are contained the the files
=server.c= and =server.h=.
#+NAME: server.h
#+BEGIN_SRC c :tangle server.h
#ifndef WWSERVER_H
#define WWSERVER_H
<<typedefs>>
<<funcdefs>>
#endif
#+END_SRC
#+NAME: server.c
#+BEGIN_SRC c :tangle server.c
#include <stdio.h>
#include <sqlite3.h>
#define HTTPSERVER_IMPL
#include "httpserver.h/httpserver.h"
#include "server.h"
<<structs>>
<<global_data>>
<<static_funcdefs>>
<<functions>>
#+END_SRC
* DONE Top Level Function (weewiki_server)
CLOSED: [2020-01-12 Sun 17:27]
The top-level function for this is =weewiki_server=. Since
this is a command line program, it takes in =argc= and
=argv= as arguments.

=weewiki server= will run the server with all the default
values. It will read the default a.db and weewiki.janet
configuration file. This will be the only thing implemented
for now.

Later, the hope is to be able to pass in a weewiki database
and have everything be served via that file (including
an embedded config file).
#+NAME: funcdefs
#+BEGIN_SRC c
int weewiki_server(int argc, char *argv[]);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int running = 1;

static void quit (int sig)
{
    running = 0;
    printf("Signal Interrupt\n");
}

int weewiki_server(int argc, char *argv[])
{
    wwserver_d wws;
    wwserver_init(&wws, "a.db", 8080);
    wwserver_global_set(&wws);
    printf("This is not yet implemented.\n");
    if (wws.server != NULL) {
        signal(SIGINT, quit);
        http_server_listen_poll(wws.server);
        while (running) {
            http_server_poll(wws.server);
        }
    }
    wwserver_clean(&wws);
    return 1;
}
#+END_SRC
* TODO Main Data
This is stuff that gets instantiated at startup.
For now, this is probably just the database, though
this could change.
** TODO Struct
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wwserver_d wwserver_d;
#+END_SRC
Database + http server.
#+NAME: structs
#+BEGIN_SRC c
struct wwserver_d {
    sqlite3 *db;
    struct http_server_s *server;
};
#+END_SRC
** WIP global data setters/getters
- State "WIP"        from "TODO"       [2020-01-12 Sun 17:29]
#+NAME: global_data
#+BEGIN_SRC c
static wwserver_d *WWS = NULL;
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void wwserver_global_set(wwserver_d *p);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void wwserver_global_set(wwserver_d *p)
{
    WWS = p;
}
#+END_SRC
#+NAME: static_funcdefs
#+BEGIN_SRC c
static wwserver_d * wwserver_global_get(void);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static wwserver_d * wwserver_global_get(void)
{
    return WWS;
}
#+END_SRC
** WIP Startup
- State "WIP"        from "TODO"       [2020-01-12 Sun 17:29]
#+NAME: funcdefs
#+BEGIN_SRC c
int wwserver_init(wwserver_d *wws, const char *filename, int port);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int wwserver_init(wwserver_d *wws, const char *filename, int port)
{
    sqlite3_open(filename, &wws->db);
    wws->server = http_server_init(port, handle_request);
    return 1;
}
#+END_SRC
** WIP Cleanup
- State "WIP"        from "TODO"       [2020-01-12 Sun 17:30]
Database is closed. May need to figure out how to cleanly
break out of loop.
#+NAME: funcdefs
#+BEGIN_SRC c
void wwserver_clean(wwserver_d *wws);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wwserver_clean(wwserver_d *wws)
{
    if (wws->server != NULL) {
        free(wws->server);
    }
    sqlite3_close(wws->db);
}
#+END_SRC
* WIP Handle Request Callback
- State "WIP"        from "TODO"       [2020-01-12 Sun 17:34]
The http server library has a single callback entry point.

The handle request callback can be divided up into the
following steps:

- URL parsing
- Writing to buffer
- Pushing buffer to HTTP body
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void handle_request(struct http_request_s* request);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
#define RESPONSE "What is my purpose?"
static void handle_request(struct http_request_s* request)
{
    /* TODO: implement */
    wwserver_d *wws;
    struct http_string_s target;
    const char *name;
    int len;
    wws = wwserver_global_get();
    target = http_request_target(request);

    if (wws == NULL) return;

    len = 0;

    if (is_wiki(&target, &name, &len)) {
        wws_buffer buf;
        sqlite3 *db;
        sqlite3_stmt *stmt;
        int rc;

        struct http_response_s* response = http_response_init();
        wws_buffer_alloc(&buf, 2048);



        db = wws->db;
        sqlite3_prepare_v2(db,
                        "SELECT value FROM wiki WHERE(key==?1);",
                        -1,
                        &stmt,
                        NULL);
        sqlite3_bind_text(stmt, 1, name, len, NULL);
        rc = sqlite3_step(stmt);

        if (rc != SQLITE_ROW) {
            wws_buffer_write(&buf,
            (const unsigned char *)"Could not find page: ", 21);
            wws_buffer_write(&buf, (const unsigned char *)name, len);
            http_response_status(response, 404);
            http_response_header(response, "Content-Type", "text/plain");
        } else {
            http_response_header(response, "Content-Type", "text/plain");
            http_response_status(response, 200);
            wws_buffer_write(&buf,
                             sqlite3_column_text(stmt, 0),
                             sqlite3_column_bytes(stmt, 0));
        }


        http_response_body(response, (const char *)buf.buf, buf.pos);
        http_respond(request, response);
        /* TODO: get page */
        /* TODO: set up parser */
        /* TODO: write to buffer */
        /* TODO: write http request */
        wws_buffer_free(&buf);
        sqlite3_finalize(stmt);
    } else {
        struct http_response_s* response = http_response_init();
        http_response_status(response, 404);
        http_response_header(response, "Content-Type", "text/plain");
        http_response_body(response, RESPONSE, sizeof(RESPONSE) - 1);
        http_respond(request, response);
    }
}
#+END_SRC
* DONE URL Parser
CLOSED: [2020-01-14 Tue 10:30]
- State "DONE"       from "WIP"        [2020-01-14 Tue 10:30]
- State "WIP"        from "TODO"       [2020-01-14 Tue 10:18]
First thing the requester does is parse the URL, this
determines what to do.

Right now, the only thing the server is programmed to do
is parse org pages to HTML and display. Pages start with
the URL =/wiki=. For example, the URL =/wiki/foo= would
display the page =foo=.

The wiki page is parsed with the function =is_wiki=. If
true, the output will return the name + length.

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int is_wiki(struct http_string_s *target,
                   const char **name,
                   int *len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int is_wiki(struct http_string_s *target,
                   const char **name,
                   int *len)
{
    /* TODO: implement */
    const char *buf;
    int size;
    int pos;

    *len = 0;


    buf = target->buf;
    size = target->len;

    if (size < 7) return 0; /* minimum: /wiki/N */


    pos = 1; /* skip first whack */


    if (!strcmp(&buf[pos], "wiki/")) return 0;

    pos += 5;

    *name = &buf[pos];
    *len = size - pos;


    return 1;
}
#+END_SRC

If it matches, the URL parser will extract the wiki page
name and attempt to retrieve it from the database.
* TODO Page Lookup
Page lookup is done via a SQLite query on the database
currently opened. Probably something like:

"SELECT value FROM wiki WHERE(key==?1);"

If the key doesn't exist, clean-up and return an error.

Otherwise, the string value is extracted from the the column
along with the size.
* TODO Org Parsing
Once the string is retrieved from the database, it is parsed
via org-parse and converted to HTML. Org parse is
provisioned with the proper HTML callbacks that write
to a buffer.
* TODO HTML buffer callbacks
Instead of writing to a file, HTML is written to a buffer.
This buffer is allocated/freed inside the request callback,
and then bound to the org parser data.

New callbacks will be required for the orgparse routine,
which will be defined below.
* TODO Writing the http request
The parsed HTML in the buffer is set to be the body of the
http request.

The status + header is set, and the the http server responds
with =http_respond=.
* TODO wiki page request cleanup
After the request is sent, there is cleanup. The buffer
is freed, and the SQLite statement is finalized via
=sqlite3_finalize=.
* WIP Buffer Management
- State "WIP"        from "TODO"       [2020-01-12 Sun 17:41]
All content must be written to in-memory location.
This is handled in a very simple way via a buffer type
called =wws_buffer=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wws_buffer wws_buffer;
#+END_SRC

A =wws_buffer= struct contains the buffer itself (an
unsigned char array), the current position of the buffer
(which is therefore the current size), and the
total size.

#+NAME: structs
#+BEGIN_SRC c
struct wws_buffer {
    int pos;
    int size;
    unsigned char *buf;
};
#+END_SRC

The =wws_buffer= is allocated with the function
=wws_buffer_alloc=. Choose a largish size because this
is the maximum HTML size for a page. Re-allocation could
come later, but for this proof-of concept, a fixed
size is simple and good enough.

#+NAME: funcdefs
#+BEGIN_SRC c
void wws_buffer_alloc(wws_buffer *wb, int size);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void wws_buffer_alloc(wws_buffer *wb, int size)
{
    wb->buf = calloc(1, size);
    wb->pos = 0;
    wb->size = size;
}
#+END_SRC

A allocated buffer must be freed with =wws_buffer_free=.

#+NAME: funcdefs
#+BEGIN_SRC c
void wws_buffer_free(wws_buffer *wb);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void wws_buffer_free(wws_buffer *wb)
{
    wb->size = 0;
    wb->pos = 0;
    free(wb->buf);
}
#+END_SRC

Write to the buffer using =wws_buffer_write=.

#+NAME: funcdefs
#+BEGIN_SRC c
void wws_buffer_write(wws_buffer *wb,
                      const unsigned char *buf,
                      int size);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void wws_buffer_write(wws_buffer *wb,
                      const unsigned char *buf,
                      int size)
{
    /* TODO: implement me */
    int i;

    if (wb->pos >= wb->size) return;

    for (i = 0; i < size; i++) {
        wb->buf[wb->pos] = buf[i];
        wb->pos++;
        if (wb->pos >= wb->size) break;
    }
}
#+END_SRC
