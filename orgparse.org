#+TITLE: Orgparse
Orgparse is a portable org-mode parser, written in ANSI C.
* Top Files
The entirety of orgparse is contained in a single header
file.

Defining =ORGPARSE_IMPLEMENTATION= will include the
functions and should only happen once per file.

Defining =ORPARSE_TEST= will include the test program.
#+NAME: orgparse.h
#+BEGIN_SRC c :tangle orgparse.h
#ifndef ORGPARSE_H
#define ORGPARSE_H
<<typedefs>>
<<funcdefs>>
#ifdef ORGPARSE_IMPLEMENTATION
<<static_funcdefs>>
<<structs>>
<<functions>>
#endif
#ifdef ORGPARSE_TEST
<<test_program>>
#endif
#endif
#+END_SRC
* Test Program
This test program can be run inside of =main=, and is
designed to be run as a command line program.
** Top Level Program
#+NAME: funcdefs
#+BEGIN_SRC c
#ifdef ORGPARSE_TEST
int orgparse_test(int argc, char *argv[]);
#endif
#+END_SRC
#+NAME: test_program
#+BEGIN_SRC c
<<test_callbacks>>
static void setup_orgparse(orgparse *op)
{
    <<setup_test_callbacks>>
}
int orgparse_test(int argc, char *argv[])
{
    orgparse op;
    FILE *fp;
    char *buf;
    size_t sz;
    if (argc == 1) {
        fprintf(stderr, "Usage: %s file.org\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[1], "r");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not open %s for reading.\n",
                argv[1]);
        return 1;
    }
    fseek(fp, 0, SEEK_END);
    sz = ftell(fp) + 1;
    buf = calloc(1, sz);
    fseek(fp, 0, SEEK_SET);
    fread(buf, 1, sz, fp);
    orgparse_init(&op);
    setup_orgparse(&op);
    orgparse_run(&op, buf, sz, NULL);
    free(buf);
    return 0;
}
#+END_SRC
** Test Callbacks
*** Header
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_header(void *ud,
                        const char *h,
                        size_t sz,
                        int lvl)
{
    printf("header: '");
    fwrite(h, 1, sz, stdout);
    printf("', lvl: %d\n", lvl);
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_header(op, test_header);
#+END_SRC
*** Text
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_text(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("text: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_text(op, test_text);
#+END_SRC
*** Bold
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_bold(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("bold: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_bold(op, test_bold);
#+END_SRC
*** Code
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_code(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("code: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_code(op, test_code);
#+END_SRC
*** Underline
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_uline(void *ud,
                       const char *str,
                       size_t sz)
{
    printf("underline: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_underline(op, test_uline);
#+END_SRC
*** Newline
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_newline(void *ud,
                         const char *str,
                         size_t sz)
{
    printf("newline\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_newline(op, test_newline);
#+END_SRC
*** Codeblock
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_codeblock(void *ud,
                           const char *str,
                           size_t sz)
{
    printf("codeblock: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_codeblock(op, test_codeblock);
#+END_SRC
* Main Interface
Orgparse is a callback interface. These functions will
handle the various parts of the org file.
** Struct
*** Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct orgparse orgparse;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct orgparse {
    <<interface>>
};
#+END_SRC
*** Init
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_init(orgparse *op);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_init(orgparse *op)
{
    <<init>>
}
#+END_SRC
** Callbacks
All callbacks have the same first 3 arguments: a generic
pointer, the string, and the length of the string.
*** Header
An org header. In addition to the header name, also supplies
the header level.
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_header)(void *,
                                const char *,
                                size_t,
                                int);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_header header;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->header = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_header(orgparse *op, orgparse_header f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_header(orgparse *op, orgparse_header f)
{
    op->header = f;
}
#+END_SRC
*** Text
This function is anything that isn't formatted text.
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_text)(void *,
                              const char *,
                              size_t);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_text text;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->text = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_text(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_text(orgparse *op, orgparse_text f)
{
    op->text = f;
}
#+END_SRC
*** Code
Text that is defined inside the =codeblock= tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text code;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->code = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_code(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_code(orgparse *op, orgparse_text f)
{
    op->code = f;
}
#+END_SRC
*** Bold
Text that is defined inside the *bold* tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text bold;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->bold = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_bold(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_bold(orgparse *op, orgparse_text f)
{
    op->bold = f;
}
#+END_SRC
*** Italic
Text that is defined inside the **italic** tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text italic;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->italic = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_italic(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_italic(orgparse *op, orgparse_text f)
{
    op->italic = f;
}
#+END_SRC
*** Underline
Text that is contained inside the _underline_ tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text underline;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->underline = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_underline(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_underline(orgparse *op, orgparse_text f)
{
    op->underline = f;
}
#+END_SRC
*** Code Block
Text inside of a code block.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text codeblock;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->codeblock = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_codeblock(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_codeblock(orgparse *op, orgparse_text f)
{
    op->codeblock = f;
}
#+END_SRC
*** Aux
A special non-org tag, used for interpolated code in tags !@
and @!.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text aux;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->aux = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_aux(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_aux(orgparse *op, orgparse_text f)
{
    op->aux = f;
}
#+END_SRC
*** Newline
The newline callback gets called anytime there is an empty
line, which means an explicit line break is needed.
For convenience, the =orgparse_text= callback is used,
though the arguments will be unused and set to =NULL=.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text newline;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->newline = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_newline(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_newline(orgparse *op, orgparse_text f)
{
    op->newline = f;
}
#+END_SRC
* Parsing
** Top Level Parse (orgparse_run)
Parsing is done using the function =orgparse_run=.
All mutable variables are declared locally, so it should
be feasible to run nested calls to this function.

=orgparse_run= expects a properly intialized + set instance
of =orgparse=, a text block, the text block size, and any
user data.
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_run(orgparse *op,
                  const char *txt,
                  size_t sz,
                  void *ud);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_run(orgparse *op,
                  const char *txt,
                  size_t sz,
                  void *ud)
{
    size_t pos;
    int mode;
    const char *blk;
    size_t len;

    mode = 0;
    len = 0;
    for (pos = 0; pos < sz; pos++) {
        if (mode == 0) {
            if (parse_comment(txt, sz, &pos)) {
                continue;
            }
            if (parse_codeblock(op, txt, sz, ud,
                                &pos, &mode, &blk, &len)) {
                continue;
            } else if (parse_header(op, txt, sz, ud, &pos)) {
                continue;
            } else {
                parse_text(op, txt, sz, ud, &pos);
            }
        } else if (mode == 1) {
            parse_codeblock(op, txt, sz, ud,
                            &pos, &mode, &blk, &len);
        }
    }
}
#+END_SRC
** Parse Header
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_header(orgparse *op,
                        const char *txt,
                        size_t sz,
                        void *ud,
                        size_t *pos);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_header(orgparse *op,
                        const char *str,
                        size_t sz,
                        void *ud,
                        size_t *pos)
{
    const char *header;
    size_t n;
    size_t start;
    int mode;
    int lvl;
    size_t hsz;
    int rc;

    if(sz - *pos < 2) return 0;
    if (str[*pos] != '*') return 0;

    start = *pos;
    mode = 0;
    lvl = 0;
    rc = 0;
    for (n = start; n < sz; n++) {
        if (mode == 2) break;
        switch (mode) {
            case 0:
                if (str[n] == '*') {
                    lvl++;
                    continue;
                } else if (str[n] == ' ') {
                    n++;
                    header = &str[n];
                    hsz = 1;
                    mode = 1;
                } else {
                    mode = 2;
                    rc = 0;
                }
                break;
            case 1:
                if (str[n] == '\n') {
                    mode = 2;
                    *pos += n - start;
                    if (op->header != NULL) {
                        op->header(ud, header, hsz, lvl);
                    }
                    rc = 1;
                    break;
                }
                hsz++;
                break;
        }
    }

    return rc;
}
#+END_SRC
** Parse Text
Text is defined by what it isn't. If it isn't a header or
code block, it is probably text. For this reason, the text
block is a "last resort".

Anything that is not a header or code block is generally
considered to be a text block. Text can span multiple lines,
and can contain special formatting tags, for things like
*bold* text, **italic** text, and _underlined_ text as well.
In addition, text can also contain links.

When a line is determined to not be anything else (header,
codeblock, aux block, etc), it is sent in to be parsed as
text.

The text block parser will read lines until it hits stuff
that is non-text. Along the way, the text will check for
formatting tags and links on a line by line basis.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_text(orgparse *op,
                      const char *txt,
                      size_t sz,
                      void *ud,
                      size_t *pos);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_text(orgparse *op,
                      const char *str,
                      size_t sz,
                      void *ud,
                      size_t *pos)
{
    size_t n;
    size_t start;
    size_t mark;
    int rc;

    rc = 0;
    start = *pos;
    mark = start;

    /* check for end of file */
    if (start == (sz - 1)) return 0;

    for (n = start; n < sz; n++) {
        if (str[n] == '\n' || n == (sz - 1)) {
            rc = 1;
            *pos += (n - start);
            if (n == mark) {
                if (op->newline != NULL) {
                    op->newline(ud, NULL, 0);
                }
            } else {
                if (op->text != NULL) {
                    /* add a newline */
                    op->text(ud,
                            &str[mark],
                            (n - mark));
                }
            }
            break;
        } else if (parse_bold(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_code(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_ul(op, str, ud, sz, &n, &mark)) {
            continue;
        }
    }
    return rc;
}
#+END_SRC
*** DONE Tag Check
CLOSED: [2019-09-21 Sat 18:39]
This functionality will generically check a line for
matching tags. If a tag is found, the end position is
returned.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int tag_check(const char *txt,
                     size_t sz,
                     char tag,
                     size_t *len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int tag_check(const char *txt,
                     size_t sz,
                     char tag,
                     size_t *len)
{
    size_t n;
    int rc;
    if (sz <= 2) return 0;
    if (txt[0] != tag) return 0;

    rc = 0;
    for (n = 1; n < sz; n++) {
        if (txt[n] == tag) {
            rc = 1;
            *len = n - 1;
            break;
        }
    }
    return rc;
}
#+END_SRC
*** Check and Parse
Checks AND parses particular tag.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int check_and_parse(orgparse *op,
                           const char *str,
                           void *ud,
                           size_t sz,
                           size_t *pos,
                           size_t *mark,
                           char tag,
                           orgparse_text f);
#+END_SRC
Setting the =mark= and =pos= variables for mark and position
took some trial and error to get right.
#+NAME: functions
#+BEGIN_SRC c
static int check_and_parse(orgparse *op,
                           const char *str,
                           void *ud,
                           size_t sz,
                           size_t *pos,
                           size_t *mark,
                           char tag,
                           orgparse_text f)
{
    size_t n, m;
    int rc;
    size_t len;

    n = *pos;
    m = *mark;
    rc = 0;
    len = 0;

    if (tag_check(&str[n],
                  sz - m,
                  tag,
                  &len)) {
        if (op->text != NULL && n != m) {
            op->text(ud, &str[m], n - m);
        }
        if (f != NULL) {
            f(ud, &str[n + 1], len);
            n += len + 2;
            m = n;
            if (n < sz && str[n] == '\n') n--;
            *pos = n;
            *mark = m;
            rc = 1;
        }
    }

    return rc;
}
#+END_SRC
*** Parse Bold
This will check and parse *bold* text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_bold(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_bold(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '*',
                           op->bold);
}
#+END_SRC
*** Parse Code.
This will check and parse =code= text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_code(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_code(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '=',
                           op->code);
}
#+END_SRC
*** Parse Underline.
This will check and parse =underline= text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_ul(orgparse *op,
                    const char *str,
                    void *ud,
                    size_t sz,
                    size_t *pos,
                    size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_ul(orgparse *op,
                    const char *str,
                    void *ud,
                    size_t sz,
                    size_t *pos,
                    size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '_',
                           op->underline);
}
#+END_SRC
** Parse Comment
Any thing that starts with '# ' (hash + space) is considered
to be a comment, and the line will be ignored.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_comment(const char *txt,
                         size_t sz,
                         size_t *pos);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_comment(const char *txt,
                         size_t sz,
                         size_t *pos)
{
    size_t start;
    size_t n;
    if ((sz - *pos) < 2) return 0;
    if (txt[*pos] != '#') return 0;
    if (txt[*pos + 1] != ' ') return 0;

    start = *pos;

    for (n = start; n < sz; n++) {
        if (txt[n] == '\n') break;
    }

    *pos += (n - start);

    return 1;
}
#+END_SRC
** Parse Command
A 'command' in org mode refers to any line that starts with
'#+'. After this, a string of alphanumeric non-space
characters creates the command name. Following this is an
arbitray number of spaces, followed by the command string.

The =parse_cmd= function will parse and extract the
command, and command string (assuming it is indeed
a command).

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_cmd(const char *str,
                     size_t sz,
                     const char **cmd,
                     size_t *cmd_len,
                     const char **cmdstr,
                     size_t *cmdstr_len,
                     size_t *total_len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_cmd(const char *str,
                     size_t sz,
                     const char **cmd,
                     size_t *cmd_len,
                     const char **cmdstr,
                     size_t *cmdstr_len,
                     size_t *total_len)
{
    size_t n;
    const char *pcmdstr;
    const char *pcmd;
    size_t len;
    int mode;
    int rc;

    if (sz < 3) return 0;
    if (str[0] != '#') return 0;
    if (str[1] != '+') return 0;
    if (str[2] == ' ') return 0;

    rc = 0;

    mode = 0;

    pcmd = &str[2];
    pcmdstr = NULL;
    len = 0;

    /* zero out lengths */

    *total_len = 0;
    *cmdstr_len = 0;
    *cmd_len = 0;

    for (n = 2; n < sz; n++) {
        if (str[n] == '\n') {
            *cmdstr_len = len;
            if (mode == 0) {
                *cmd_len = len;
                *cmdstr_len = 0;
                rc = 1;
            }
            break;
        }
        switch (mode) {
            case 0: /* command string */
                if (str[n] == ' ') {
                    mode = 1;
                    *cmd_len = len;
                    len = 0;
                    rc = 1;
                    break;
                }
                len++;
                break;
            case 1:
                if (str[n] != ' ') {
                    mode = 2;
                    len = 1;
                    pcmdstr = &str[n];
                }
                break;
            case 2:
                len++;
                break;
        }
    }

    *cmdstr = pcmdstr;
    *cmd = pcmd;
    *total_len = n * rc;

    return rc;
}
#+END_SRC
** Parse Codeblock
A codeblock is a set of lines smooshed between
'#+BEGIN_SRC' and '#+END_SRC' tags.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_codeblock(orgparse *op,
                           const char *txt,
                           size_t sz,
                           void *ud,
                           size_t *pos,
                           int *mode,
                           const char **blk,
                           size_t *blklen);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_codeblock(orgparse *op,
                           const char *txt,
                           size_t sz,
                           void *ud,
                           size_t *pos,
                           int *mode,
                           const char **blk,
                           size_t *blklen)
{
    int rc;
    size_t start;
    size_t cmdlen;
    size_t cmdstrlen;
    const char *cmd;
    const char *cmdstr;
    size_t totallen;
    size_t n;

    start = *pos;
    cmdlen = 0;
    cmdstrlen = 0;
    totallen = 0;
    rc = parse_cmd(&txt[start],
                   sz,
                   &cmd,
                   &cmdlen,
                   &cmdstr,
                   &cmdstrlen,
                   &totallen);
    *pos += totallen;

    if (rc) {
        if (*mode == 0) {
            if (!strncmp(cmd, "BEGIN_SRC", cmdlen)) {
                *blk = &txt[*pos + 1];
                *blklen = 0;
                *mode = 1;
            }
        } else if (*mode == 1) {

            if (!strncmp(cmd, "END_SRC", cmdlen)) {
                *mode = 0;
                if (op->codeblock != NULL) {
                    op->codeblock(ud, *blk, *blklen - 1);
                }
                *blk = NULL;
                *blklen = 0;
            }
        }
    }

    /* Read a line */
    if (*mode == 1) {
        rc = 1;
        for (n = start; n < sz; n++) {
            if (txt[n] == '\n') break;
        }
        *pos += (n - start);
        *blklen += (n - start) + 1;
    }

    return rc;
}
#+END_SRC
