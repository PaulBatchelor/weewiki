#+TITLE: Orgparse
Orgparse is a portable org-mode parser, written in ANSI C.
* Top Files
The entirety of orgparse is contained in a single header
file.

Defining =ORGPARSE_IMPLEMENTATION= will include the
functions and should only happen once per file.

Defining =ORPARSE_TEST= will include the test program.
#+NAME: orgparse.h
#+BEGIN_SRC c :tangle orgparse.h
#ifndef ORGPARSE_H
#define ORGPARSE_H
<<typedefs>>
#ifdef ORGPARSE_IMPLEMENTATION
<<structs>>
#endif
<<funcdefs>>
#ifdef ORGPARSE_IMPLEMENTATION
<<static_funcdefs>>
<<functions>>
#endif
#ifdef ORGPARSE_TEST
<<test_program>>
#endif
#endif
#+END_SRC
* Test Parser
This test program can be run inside of =main=, and is
designed to be run as a command line program.
** Top Level Program
#+NAME: funcdefs
#+BEGIN_SRC c
#ifdef ORGPARSE_TEST
int orgparse_test(int argc, char *argv[]);
#endif
#+END_SRC
#+NAME: test_program
#+BEGIN_SRC c
<<test_callbacks>>
static void setup_orgparse(orgparse *op)
{
    <<setup_test_callbacks>>
}
int orgparse_test_parser(int argc, char *argv[])
{
    orgparse op;
    FILE *fp;
    char *buf;
    size_t sz;

    if (argc == 1) {
        fprintf(stderr, "Usage: %s file.org\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[1], "r");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not open %s for reading.\n",
                argv[1]);
        return 1;
    }
    fseek(fp, 0, SEEK_END);
    sz = ftell(fp) + 1;
    buf = calloc(1, sz);
    fseek(fp, 0, SEEK_SET);
    fread(buf, 1, sz, fp);
    orgparse_init(&op);
    setup_orgparse(&op);
    orgparse_run(&op, buf, sz, NULL);
    free(buf);
    return 0;
}
#+END_SRC
** Test Callbacks
*** Header
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_header(void *ud,
                        const char *h,
                        size_t sz,
                        int lvl)
{
    printf("header: '");
    fwrite(h, 1, sz, stdout);
    printf("', lvl: %d\n", lvl);
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_header(op, test_header);
#+END_SRC
*** Text
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_text(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("text: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_text(op, test_text);
#+END_SRC
*** Bold
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_bold(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("bold: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_bold(op, test_bold);
#+END_SRC
*** Code
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_code(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("code: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_code(op, test_code);
#+END_SRC
*** Underline
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_uline(void *ud,
                       const char *str,
                       size_t sz)
{
    printf("underline: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_underline(op, test_uline);
#+END_SRC
*** Newline
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_newline(void *ud,
                         const char *str,
                         size_t sz)
{
    printf("newline\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_newline(op, test_newline);
#+END_SRC
*** Codeblock
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_codeblock(void *ud,
                           const char *str,
                           size_t sz)
{
    printf("codeblock: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_codeblock(op, test_codeblock);
#+END_SRC
*** Name
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_name(void *ud,
                           const char *str,
                           size_t sz)
{
    printf("name: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_name(op, test_name);
#+END_SRC
*** Aux Block
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_aux(void *ud,
                     const char *str,
                     size_t sz)
{
    printf("aux: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_aux(op, test_aux);
#+END_SRC
*** Title
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_title(void *ud,
                       const char *str,
                       size_t sz)
{
    printf("title: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_title(op, test_title);
#+END_SRC
*** Link
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_link(void *ud,
                      const char *link,
                      size_t link_sz,
                      const char *name,
                      size_t name_sz)
{
    printf("link_ref: '");
    fwrite(link, 1, link_sz, stdout);
    printf("', '");
    fwrite(name, 1, name_sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_link(op, test_link);
#+END_SRC
*** Paragraph
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_pgrph(void *ud, int mode)
{
    if (mode) {
        printf("PARAGRAPH END\n");
    } else {
        printf("PARAGRAPH BEGIN\n");
    }
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_pgrph(op, test_pgrph);
#+END_SRC
* Test Suite
A test suite is used to ensure that things function the way
they are supposed to.
** Top
#+NAME: funcdefs
#+BEGIN_SRC c
#ifdef ORGPARSE_TEST
int orgparse_test_suite(void);
#endif
#+END_SRC
#+NAME: test_program
#+BEGIN_SRC c
typedef struct {
    const char *name;
    int (*test)(void);
} test_entry;

enum {
    OK,
    FAIL,
    IGNORE
};

<<tests>>

test_entry Tests[] =
{
    <<test_entries>>
};

int orgparse_test_suite(void)
{
    int n;
    int ntests;
    test_entry *e;
    int rc;
    int nerr;

    ntests = sizeof(Tests)/sizeof(*Tests);
    rc = 0;
    nerr = 0;

    for(n = 0; n < ntests; n++) {
        e = &Tests[n];
        rc = e->test();
        printf("[%d/%d] %s: ", n + 1, ntests, e->name);
        switch (rc) {
            case OK:
                printf("OK\n");
                break;
            case FAIL:
                nerr++;
                printf("FAIL\n");
                break;
            default:
                printf("???\n");
                break;
        }
    }

    if (nerr) {
        printf("\nTest suite failed with %d error(s)\n", nerr);
        rc = 1;
    } else {
        printf("\nTest suite successful\n");
        rc = 0;
    }
    return rc;
}
#+END_SRC
** Tests
*** Template Test
Just to get things started. A boilerpalte test that
returns "okay".
#+NAME: test_entries
#+BEGIN_SRC c
{"Template Test", test_foo},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
static int test_foo(void)
{
    return OK;
}
#+END_SRC
*** Extra Newline at Ending Aux Block
This is a particular edge case that happens when an aux
block ends up at the end of a text block. It will go and
print an extra newline statement.
#+NAME: test_entries
#+BEGIN_SRC c
{"Extra newline at ending aux block", test_ending_auxblock},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
static void ending_auxblock_newline(void *ud,
                                    const char *str,
                                    size_t sz)
{
    int *nl;
    nl = ud;
    *nl = (*nl) + 1;
}

static int test_ending_auxblock(void)
{
    orgparse op;
    int nl;
    int rc;

    nl = 0;
    orgparse_init(&op);
    orgparse_set_newline(&op, ending_auxblock_newline);
    orgparse_run(&op, "@! some text !@\n\none.", 23, &nl);
    rc = OK;
    if (nl != 0) {
        printf("%d newlines when it should have been 0\n",
               nl);
        rc = FAIL;
    }
    return rc;
}
#+END_SRC
*** Text Before Code Block
Text before a block causes a code block to glitchy by one.
#+NAME: test_entries
#+BEGIN_SRC c
{"Text before codeblock", test_text_before_blk},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    const char *code;
    size_t sz;
    int found_codeblock;
    int off_by_one;
} tbb_d;

static void tbb_codeblock(void *ud,
                          const char *str,
                          size_t sz)
{
    tbb_d *tbb;
    tbb = ud;

    tbb->code = str;
    tbb->sz = sz;
    tbb->found_codeblock = 1;
}

static void tbb_text(void *ud,
                     const char *str,
                     size_t sz)
{
    tbb_d *tbb;
    tbb = ud;

    if (str[0] == '+') {
        tbb->off_by_one = 1;
    }
}

static int test_text_before_blk(void)
{
    orgparse op;
    tbb_d tbb;
    const char *str =
        "one.\n"
        "#+NAME: block\n"
        "#+BEGIN_SRC text\n"
        "this is a codeblock.\n"
        "#+END_SRC";
    int rc;

    tbb.sz = 0;
    tbb.code = NULL;
    tbb.found_codeblock = 0;
    tbb.off_by_one = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_codeblock(&op, tbb_codeblock);
    orgparse_set_text(&op, tbb_text);
    orgparse_run(&op, str, strlen(str), &tbb);

    if (!tbb.found_codeblock) {
        printf("Codeblock not found\n");
        rc = FAIL;
    }

    if (tbb.off_by_one) {
        printf("Codeblock parser is off by one (+BEGIN)\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Invalid Paragraph Start
This happens at the end of a file with any non-text thing
(such as a header). While that bug has been fixed, a new
bug has occured where a header does not get parsed if there
is no newline. Trying to get to the bottom of that as well
now.
#+NAME: test_entries
#+BEGIN_SRC c
{"Invalid Paragraph Start", test_invalid_pgrph},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int found;
    int headers;
} ip_d;

static void ip_pgrph(void *ud, int mode)
{
    ip_d *ip;
    ip = ud;
    ip->found++;
}

static void ip_header(void *ud, const char *str, size_t sz, int lvl)
{
    ip_d *ip;
    ip = ud;
    ip->headers++;
}

static int test_invalid_pgrph(void)
{
    orgparse op;
    int rc;
    ip_d ip;
    const char *str = "* A\n* B";

    ip.found = 0;
    ip.headers = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_pgrph(&op, ip_pgrph);
    orgparse_set_header(&op, ip_header);
    orgparse_run(&op, str, strlen(str), &ip);

    if (ip.found) {
        printf("Found %d paragraph calls\n", ip.found);
        rc = FAIL;
    }

    if (ip.headers != 2) {
        printf("Found %d headers, expected 2\n",
               ip.headers);
    }

    return rc;
}
#+END_SRC
*** New paragraph block after header
For some reason, a new paragraph block will not start in
a second header. This test will make sure it passes.
#+NAME: test_entries
#+BEGIN_SRC c
{"New Paragraph After Block Header", test_new_pgrph},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int found;
    int headers;
} np_d;

static void np_pgrph(void *ud, int mode)
{
    np_d *np;
    np = ud;
    if (mode == 0) np->found++;
}

static void np_header(void *ud, const char *str, size_t sz, int lvl)
{
    np_d *np;
    np = ud;
    np->headers++;
}

static int test_new_pgrph(void)
{
    orgparse op;
    int rc;
    np_d np;
    const char *str = "* A\n123\n* B\n456";

    np.found = 0;
    np.headers = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_pgrph(&op, np_pgrph);
    orgparse_set_header(&op, np_header);
    orgparse_run(&op, str, strlen(str), &np);

    if (np.found != 2) {
        printf("Found %d paragraph call(s)\n", np.found);
        printf("Expected 2\n");
        rc = FAIL;
    }

    if (np.headers != 2) {
        printf("Found %d headers, expected 2\n",
               np.headers);
    }

    return rc;
}
#+END_SRC
*** Starting new paragraphs
A new paragraph should happen when there is an empty line.
#+NAME: test_entries
#+BEGIN_SRC c
{"Starting new paragraphs", test_start_pgrph},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int n;
} sp_d;

static void sp_pgrph(void *ud, int mode)
{
    sp_d *sp;
    sp = ud;
    if (mode == 0) sp->n++;
}

static int test_start_pgrph(void)
{
    orgparse op;
    int rc;
    sp_d sp;
    const char *str = "abc\n\ndef\n\nghi";

    sp.n = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_pgrph(&op, sp_pgrph);
    orgparse_run(&op, str, strlen(str), &sp);

    if (sp.n != 3) {
        printf("Found %d paragraph start(s). ", sp.n);
        printf("Expected 3.\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Multiple Aux Blocks.
Two aux blocks, separated by an empty line, currently
causes the second auxblock to be parsed as text.
#+NAME: test_entries
#+BEGIN_SRC c
{"Multiple Aux Blocks", test_mult_auxblocks},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int na;
} ma_d;

static void na_aux(void *ud, const char *buf, size_t sz)
{
    ma_d *ma;
    ma = ud;
    ma->na++;
}

static int test_mult_auxblocks(void)
{
    orgparse op;
    int rc;
    ma_d ma;
    const char *str = "@!foo!@\n\n@!bar!@";

    ma.na = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_aux(&op, na_aux);
    orgparse_run(&op, str, strlen(str), &ma);

    if (ma.na != 2) {
        printf("Found %d aux blocks. ", ma.na);
        printf("Expected 2.\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Start a new block within a block
This problem happens with the following weewiki text.

#+BEGIN_SRC text
@!(org "foo")!@

@!(org "bar")!@

@!(org "cat")!@
#+END_SRC

This generates the following html:

#+BEGIN_SRC html
<p>foo</p>
bar<br>
cat</p>
#+END_SRC

When it should be more like:

#+BEGIN_SRC html
<p>foo</p>
<p>bar</p>
<p>car</p>
#+END_SRC

This test aims to reproduce the situations, and count
the number of paragraph starts. It *should* be 3 starts,
but it currently only returns 1.
#+NAME: test_entries
#+BEGIN_SRC c
{"Start block within a block", test_block_block},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int b;
    int e;
    int t;
    orgparse_state s;
} bb_d;

static void bb_aux(void *ud, const char *buf, size_t sz)
{
    bb_d *bb;
    bb = ud;

    orgparse_run_txtmode(bb->s.op,
                         buf, sz,
                         bb,
                         bb->s.flags->txtmode);
}

static void bb_pgrph(void *ud, int mode)
{
    bb_d *bb;
    bb = ud;
    if (mode == 0) bb->b++;
    else bb->e++;
}

static void bb_txt(void *ud, const char *buf, size_t sz)
{
    bb_d *bb;
    bb = ud;
    bb->t++;
}

static int test_block_block(void)
{
    orgparse op;
    int rc;
    bb_d bb;
    const char *str = "@!foo!@\n\n@!bar!@\n\n@!cat!@";

    bb.b = 0;
    bb.e = 0;
    bb.t = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_aux(&op, bb_aux);
    orgparse_set_pgrph(&op, bb_pgrph);
    orgparse_set_text(&op, bb_txt);
    orgparse_state_init(&bb.s, &op, str, strlen(str), &bb);
    orgparse_state_run(&bb.s);
    orgparse_end(&op, &bb, &bb.s);

    if (bb.b != 3) {
        printf("Found %d paragraphs begins. ", bb.b);
        printf("Expected 3.\n");
        rc = FAIL;
    }

    if (bb.e != 3) {
        printf("Found %d paragraphs ends. ", bb.e);
        printf("Expected 3.\n");
        rc = FAIL;
    }

    if (bb.t != 3) {
        printf("Found %d textblocks. ", bb.t);
        printf("Expected 3.\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Wrap-up always has end paragraph
Things always end up in text mode, regardless of mode.
This causes an end paragraph callback to happen.
#+NAME: test_entries
#+BEGIN_SRC c
{"Invalid end paragraph at wrapup", test_ep_at_wrapup},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int e;
    int b;
} epwu_d;

static void epwu_pgrph(void *ud, int mode)
{
    epwu_d *epwu;
    epwu = ud;
    if (mode == 0) epwu->b++;
    else epwu->e++;
}

static int test_ep_at_wrapup(void)
{
    orgparse op;
    int rc;
    epwu_d epwu;
    const char *str = "* Header\n";
    int out;

    epwu.b = 0;
    epwu.e = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_pgrph(&op, epwu_pgrph);
    out = orgparse_run(&op, str, strlen(str), &epwu);
    orgparse_wrapup(&op, &epwu, out);

    if (epwu.e != 0) {
        printf("Found %d paragraphs ends. ", epwu.e);
        printf("Expected no paragraph ends.\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Parsing Continuations
Parsing continuations refer to being able save state
information between multiple parse calls, to the point
where functionally, it is all one continuous parse call.

At the time of writing, this sort of functionality does not
exactly exist, but it is needed if Janet is to parse org
blocks.

Right now, the following code will make two paragraphs out
of the words "foo" and "bar", because of the extra line
break.

#+BEGIN_SRC text
foo

bar
#+END_SRC

This should do the same thing in weewiki markup + Janet,
but right now it doesn't. I think it is because state is not
being saved. Only one paragraph block is being registered.

#+BEGIN_SRC text
@!
(org "foo\n\n")
(org "bar\n")
!@
#+END_SRC

This test will simulate what is happening in the Janet code,
and count the paragraph starts/ends.
#+NAME: test_entries
#+BEGIN_SRC c
{"Parsing Continuations", test_continuations},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int b;
    int e;
    orgparse_state s1;
    orgparse_state s2;
} cont_d;

static void cont_pgrph(void *ud, int mode)
{
    cont_d *cont;
    cont = ud;
    if (mode == 0) cont->b++;
    else cont->e++;
}

static int test_continuations(void)
{
    orgparse op;
    int rc;
    cont_d cont;
    int out;
    orgparse_state_flags *f;
    const char *blk1 = "foo\n\n";
    const char *blk2 = "bar\n";

    cont.b = 0;
    cont.e = 0;

    rc = OK;

    orgparse_init(&op);

    orgparse_set_pgrph(&op, cont_pgrph);

    /* parse first block */

    orgparse_state_init(&cont.s1, &op, blk1, strlen(blk1), &cont);
    orgparse_state_run(&cont.s1);

    /* parse second block */
    orgparse_state_init(&cont.s2, &op, blk2, strlen(blk2), &cont);

    f = orgparse_state_flags_get(&cont.s1);

    if (f->newline == 0) {
        printf("Expected newline flag to be toggled on\n");
        rc = FAIL;
    }

    orgparse_state_flags_set(&cont.s2, f);
    out = orgparse_state_run(&cont.s2);


    orgparse_wrapup(&op, &cont, out);

    if (cont.b != 2) {
        printf("Found %d paragraphs begins. ", cont.b);
        printf("Expected 2.\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Parse formatted text after newline
It seems my newline logic has added a new bug.
So that's fun. Currently, any new paragraph that starts
with formatted text or a link will get treated as plaintext.

This test will isolate the incident and try to do bold
text on a newline. If no bold text is to be found, it is
a bug.
#+NAME: test_entries
#+BEGIN_SRC c
{"Parse formatted text after newline", test_formnl},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int b;
} formnl_d;

static void formnl_bold(void *ud, const char *s, size_t sz)
{
    formnl_d *f;
    f = ud;
    f->b++;
}

static int test_formnl(void)
{
    orgparse op;
    formnl_d f;
    int rc;
    const char *txt = "text.\n\n*bold* text\n";

    rc = OK;
    orgparse_init(&op);
    f.b = 0;

    orgparse_set_bold(&op, formnl_bold);

    orgparse_run(&op, txt, strlen(txt), &f);

    if (f.b == 0) {
        printf("No bolds found\n");
        rc = FAIL;
    } else if (f.b != 1) {
        printf("Got %d bolds, expected only 1\n", f.b);
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Rogue Paragraph
This happens anytime there is a line break at the end of
a file, like so:

#+BEGIN_SRC text
Text.

#+END_SRC

Running =orgparse_test run= on this will produce the
following:

#+BEGIN_SRC text
PARAGRAPH BEGIN
text: 'Text.
'
PARAGRAPH END
PARAGRAPH END
#+END_SRC

I am guessing this has to do with the =orgparse_wrapup=
logic.

#+NAME: test_entries
#+BEGIN_SRC c
{"Rogue Paragraph End", test_rp},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int e;
} rp_d;

static void rp_pgrph(void *ud, int mode)
{
    rp_d *rp;
    rp = ud;
    if (mode) rp->e++;
}

static int test_rp(void)
{
    orgparse op;
    rp_d rp;
    int rc;
    orgparse_state state;
    const char *txt = "text.\n\n";

    rc = OK;
    orgparse_init(&op);
    rp.e = 0;

    orgparse_set_pgrph(&op, rp_pgrph);

    orgparse_init_and_run(&op,
                          txt,
                          strlen(txt),
                          &rp,
                          &state);
    orgparse_end(&op, &rp, &state);

    if (rp.e != 1) {
        printf("Wrong number of end paragraphs\n");
        printf("Expected 1, got %d\n", rp.e);
        if (rp.e == 2) {
            printf("Suspected rogue paragraph detected\n");
        }
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Newline after formatted text causes paragraph end
#+NAME: test_entries
#+BEGIN_SRC c
{"Paragraph after newlined formatted text", test_nlformpe},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int cnt;
} nlformpe_d;

static void nlformpe_pgrph(void *ud, int mode)
{
    nlformpe_d *x;
    x = ud;
    if (mode == 0) x->cnt++;
}

static int test_nlformpe(void)
{
    orgparse op;
    nlformpe_d x;
    int rc;
    const char *txt = "*foo*\nbar";

    rc = OK;
    orgparse_init(&op);
    x.cnt = 0;

    orgparse_set_pgrph(&op, nlformpe_pgrph);

    orgparse_run(&op, txt, strlen(txt), &x);

    if (x.cnt == 2) {
        printf("Incorrect number of paragarphs found\n");
        printf("Should only be 1.\n");
        printf("This is an expected bug.\n");
        rc = FAIL;
    } else if (x.cnt != 1) {
        printf("Unexpected number of paragraphs: %d",
               x.cnt);
    }

    return rc;
}
#+END_SRC
*** TODO Paragraphs ending with link causes newline
This text:
#+BEGIN_SRC text
[[link]]

[[link]]
#+END_SRC

Causes the following to happen
#+BEGIN_SRC text
PARAGRAPH BEGIN
link_ref: 'link', 'link'
PARAGRAPH END
newline
PARAGRAPH BEGIN
link_ref: 'link', 'link'
PARAGRAPH END
#+END_SRC

The "newline" shouldn't be there. The test define below runs
this text through the parser and sees if the newline
callback gets called. If it does, the test has failed.

#+NAME: test_entries
#+BEGIN_SRC c
{"Paragraph ending with link causes newline", test_linknl},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
static void linknl_nl(void *ud,
                      const char *dumb,
                      size_t dumbr)
{
    int *x;
    x = ud;
    *x = *x + 1; /* *x++ works too? */
}

static int test_linknl(void)
{
    orgparse op;
    int rc;
    int cnt;

    const char *txt = "[[link]]\n\n[[link]]";
    cnt = 0;

    rc = OK;
    orgparse_init(&op);

    orgparse_set_newline(&op, linknl_nl);

    orgparse_run(&op, txt, strlen(txt), &cnt);

    if (cnt != 0) {
        printf("Found a newline. Oops.\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
* Main Interface
Orgparse is a callback interface. These functions will
handle the various parts of the org file.
** Struct
*** Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct orgparse orgparse;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct orgparse {
    <<interface>>
};
#+END_SRC
*** Init
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_init(orgparse *op);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_init(orgparse *op)
{
    <<init>>
}
#+END_SRC
*** Size
When using is opaquely.
#+NAME: funcdefs
#+BEGIN_SRC c
size_t orgparse_size(void);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
size_t orgparse_size(void)
{
    return sizeof(orgparse);
}
#+END_SRC
** Callbacks
All callbacks have the same first 3 arguments: a generic
pointer, the string, and the length of the string.
*** Header
An org header. In addition to the header name, also supplies
the header level.
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_header)(void *,
                                const char *,
                                size_t,
                                int);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_header header;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->header = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_header(orgparse *op, orgparse_header f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_header(orgparse *op, orgparse_header f)
{
    op->header = f;
}
#+END_SRC
*** Text
This function is anything that isn't formatted text.
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_text)(void *,
                              const char *,
                              size_t);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_text text;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->text = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_text(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_text(orgparse *op, orgparse_text f)
{
    op->text = f;
}
#+END_SRC
*** Code
Text that is defined inside the =codeblock= tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text code;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->code = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_code(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_code(orgparse *op, orgparse_text f)
{
    op->code = f;
}
#+END_SRC
*** Bold
Text that is defined inside the *bold* tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text bold;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->bold = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_bold(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_bold(orgparse *op, orgparse_text f)
{
    op->bold = f;
}
#+END_SRC
*** Italic
Text that is defined inside the **italic** tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text italic;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->italic = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_italic(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_italic(orgparse *op, orgparse_text f)
{
    op->italic = f;
}
#+END_SRC
*** Underline
Text that is contained inside the _underline_ tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text underline;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->underline = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_underline(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_underline(orgparse *op, orgparse_text f)
{
    op->underline = f;
}
#+END_SRC
*** Code Block
Text inside of a code block.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text codeblock;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->codeblock = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_codeblock(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_codeblock(orgparse *op, orgparse_text f)
{
    op->codeblock = f;
}
#+END_SRC
*** Aux
A special non-org tag, used for interpolated code in tags !@
and @!.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text aux;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->aux = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_aux(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_aux(orgparse *op, orgparse_text f)
{
    op->aux = f;
}
#+END_SRC
*** Newline
The newline callback gets called anytime there is an empty
line, which means an explicit line break is needed.
For convenience, the =orgparse_text= callback is used,
though the arguments will be unused and set to =NULL=.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text newline;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->newline = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_newline(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_newline(orgparse *op, orgparse_text f)
{
    op->newline = f;
}
#+END_SRC
*** Name
Handles a 'NAME' command.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text name;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->name = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_name(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_name(orgparse *op, orgparse_text f)
{
    op->name = f;
}
#+END_SRC
*** Title
Handles a titlecommand.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text title;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->title = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_title(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_title(orgparse *op, orgparse_text f)
{
    op->title = f;
}
#+END_SRC
*** Link
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_link)(void *,
                              const char *,
                              size_t,
                              const char *,
                              size_t);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_link link;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->link = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_link(orgparse *op, orgparse_link f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_link(orgparse *op, orgparse_link f)
{
    op->link = f;
}
#+END_SRC
*** Paragraph
The pargraph callback gets called anytime a paragraph block
starts or end. For HTML generation, this will be in charge
of generating p-tags.

A paragraph starts when a new text block begins, and ends
with a line break, or major mode change (such as for a code
block or header).
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_pgrph)(void *, int);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_pgrph pgrph;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->pgrph = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_pgrph(orgparse *op, orgparse_pgrph f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_pgrph(orgparse *op, orgparse_pgrph f)
{
    op->pgrph = f;
}
#+END_SRC

A paragraph begins with =orgparse_pgrph_begin=.
A paragraph ends with =orgparse_pgrph_end=.
Note that neither of these functions actually check to see
if they are *supposed* to be beginning or ending. That logic
is done elsewhere.

#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_pgrph_begin(orgparse *op, void *ud);
void orgparse_pgrph_end(orgparse *op, void *ud);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_pgrph_begin(orgparse *op, void *ud)
{
    if (op->pgrph != NULL) {
        op->pgrph(ud, 0);
    }
}

void orgparse_pgrph_end(orgparse *op, void *ud)
{
    if (op->pgrph != NULL) {
        op->pgrph(ud, 1);
    }
}
#+END_SRC

Paragraphs do not end at the end of a file. It will need to
be ended with =orgparse_wrapup=.

Note: this is *deprecated* and should be removed ASAP.

#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_wrapup(orgparse *op, void *ud, int rc);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_wrapup(orgparse *op, void *ud, int rc)
{
    if (rc) {
        orgparse_pgrph_end(op, ud);
    }
}
#+END_SRC

A new version of =orgparse_wrapup= is used, this time taking
in an =orgparse_state= variable. We'll call it
=orgparse_end=.

This was created because the single rc flag (txtmode) alone
was giving some false positives, and rogue paragraph ends
were happening.

This new function checks both the =txtmode=
and =newline= flags. A paragraph end will only happen when
the =newline= flag is not set.

#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_end(orgparse *op,
                  void *ud,
                  orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_end(orgparse *op,
                  void *ud,
                  orgparse_state *state)
{
    int rc;
    rc =
        state->flags->txtmode &&
        state->flags->newline == 0;

    if (rc) {
        orgparse_pgrph_end(op, ud);
    }
}
#+END_SRC
* Parsing
** Top Level Parse (orgparse_run)
Parsing is done using the function =orgparse_run=.
All mutable variables are declared locally, so it should
be feasible to run nested calls to this function.

=orgparse_run= expects a properly intialized + set instance
of =orgparse=, a text block, the text block size, and any
user data.
*** Normal
#+NAME: funcdefs
#+BEGIN_SRC c
int orgparse_run(orgparse *op,
                 const char *txt,
                 size_t sz,
                 void *ud);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int orgparse_run(orgparse *op,
                 const char *txt,
                 size_t sz,
                 void *ud)
{
    orgparse_state state;
    orgparse_init_and_run(op, txt, sz, ud, &state);
    orgparse_end(op, ud, &state);
    return 0; /* TODO: remove return value */
}
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
int orgparse_init_and_run(orgparse *op,
                          const char *txt,
                          size_t sz,
                          void *ud,
                          orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int orgparse_init_and_run(orgparse *op,
                          const char *txt,
                          size_t sz,
                          void *ud,
                          orgparse_state *state)
{
    orgparse_state_init(state, op, txt, sz, ud);
    return orgparse_state_run(state);
}
#+END_SRC
*** Text Mode (Please deprecate)
By default, the =orgparse_run= function starts with textmode
set to be false. However, this can cause problems with
inline org generation via Janet. This function allows the
textmode to be set before starting.
#+NAME: funcdefs
#+BEGIN_SRC c
int orgparse_run_txtmode(orgparse *op,
                         const char *txt,
                         size_t sz,
                         void *ud,
                         int txtmode);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int orgparse_run_txtmode(orgparse *op,
                         const char *txt,
                         size_t sz,
                         void *ud,
                         int txtmode)
{
    orgparse_state state;
    orgparse_state_init(&state, op, txt, sz, ud);
    state.flags->txtmode = txtmode;
    return orgparse_state_run(&state);
}
#+END_SRC
** Orgparse State
To make orgparse re-entrant, all mutable data is stored in
a state.
*** Orgparse Struct
All mutable orgparse data is contained inside of a struct
called =orgparse_state=, which gets instantiated with every
call to =orgparse_run=. This allows =orgparse_run= to be
re-entrant, which is a needed requirement in order for
weewiki's scripting capabilities to really work.
**** Struct Declarations
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct orgparse_state orgparse_state;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
<<orgparse_flags_struct>>
struct orgparse_state {
    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t pos;
    const char *blk;
    size_t len;
    <<state_flags_in_struct>>
};
#+END_SRC
**** Flags Struct
The flags struct is a component of the =orgparse_state=.
These flags are used to determine position the parser
state machine.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct orgparse_state_flags orgparse_state_flags;
#+END_SRC
***** The Flags
The =mode= flag is used to determine the large scale parsing
mode, and is used to do general org-mode parsing or aux
block parsing.

The =txtmode= flag is boolean value set every time the
parser goes to parse a text block. It is used to help
indicate when a new paragraph block should begin.

The =newline= flag is used to determine whether or not
a =newline= character has been found. This is used to
add explicit breaks, as well as start new paragraph blocks.
#+NAME: orgparse_flags_struct
#+BEGIN_SRC c
struct orgparse_state_flags {
    int mode;
    int txtmode;
    int newline;
};
#+END_SRC
***** Flags in orgparse state
The =orgparse_state= struct has two =orgparse_state_flags=
variables: an internal flags value =iflags=, and a pointer
value =flags=. By default, =flags= points to the internal
value, but this can be overridden to be an external value.
The reasoning for having this feature is to allow more
seamless org code parsing generation in the Janet scriping
engine via the =org= command.
#+NAME: state_flags_in_struct
#+BEGIN_SRC c
orgparse_state_flags *flags;
orgparse_state_flags iflags;
#+END_SRC
To override flags, use the =orgparse_state_flags_set=
function. To get the internal flags, use
=orgparse_state_flags_get=.
#+NAME: funcdefs
#+BEGIN_SRC c
orgparse_state_flags *orgparse_state_flags_get(orgparse_state *s);
void orgparse_state_flags_set(orgparse_state *s,
                              orgparse_state_flags *f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
orgparse_state_flags *orgparse_state_flags_get(orgparse_state *s)
{
    return s->flags;
}
void orgparse_state_flags_set(orgparse_state *s,
                              orgparse_state_flags *f)
{
    s->flags = f;
}
#+END_SRC
**** Struct Init
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_state_init(orgparse_state *state,
                         orgparse *op,
                         const char *txt,
                         size_t sz,
                         void *ud);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_state_init(orgparse_state *state,
                         orgparse *op,
                         const char *txt,
                         size_t sz,
                         void *ud)
{
    state->op = op;
    state->txt = txt;
    state->sz = sz;
    state->pos = 0;
    state->flags = &state->iflags;
    state->flags->mode = 0;
    state->flags->txtmode = 0;
    state->len = 0;
    state->ud = ud;
    state->blk = NULL;
    state->flags->newline = 0;
}
#+END_SRC
**** Size
#+NAME: funcdefs
#+BEGIN_SRC c
size_t orgparse_state_size(void);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
size_t orgparse_state_size(void)
{
    return sizeof(orgparse_state);
}
#+END_SRC
*** State Run
#+NAME: funcdefs
#+BEGIN_SRC c
int orgparse_state_run(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int orgparse_state_run(orgparse_state *state)
{
    int txtmode;
    size_t sz;

    txtmode = 0;

    sz = state->sz;

    if (state->txt[sz - 1] == '\0') {
        sz--;
    }

    for (state->pos = 0; state->pos < sz; state->pos++) {
        txtmode = 0;
        if (state->flags->mode == 0) {
            if (parse_comment(state)) {
                continue;
            }
            if (parse_codeblock(state)) {
                continue;
            } else if (parse_header(state)) {
                continue;
            } else if (parse_name(state)) {
                continue;
            } else if (parse_title(state)) {
                continue;
            } else {
                if (!state->flags->txtmode) {
                    if (state->pos < (state->sz - 1)) {
                        orgparse_pgrph_begin(state->op,
                                            state->ud);
                        state->flags->newline = 0;
                    }
                }
                txtmode = 1;
                parse_text(state);
            }
        } else if (state->flags->mode == 1) {
            parse_codeblock(state);
        } else if (state->flags->mode == 2) {
            if (state->flags->txtmode) txtmode = 1;
            if (parse_aux_doiend(state)) {
                <<end_the_aux_block>>
            } else {
                <<increment_aux_line>>
            }
        }
        state->flags->txtmode = txtmode;
    }
    return txtmode;
}
#+END_SRC
** Parse Header
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_header(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_header(orgparse_state *state)
{
    const char *header;
    size_t n;
    size_t start;
    int mode;
    int lvl;
    size_t hsz;
    int rc;

    orgparse *op;
    const char *str;
    size_t sz;
    void *ud;
    size_t *pos;

    op = state->op;
    str = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;

    if(sz - *pos < 2) return 0;
    if (str[*pos] != '*') return 0;

    start = *pos;
    mode = 0;
    lvl = 0;
    rc = 0;
    for (n = start; n < sz; n++) {
        if (mode == 2) break;
        switch (mode) {
            case 0:
                if (str[n] == '*') {
                    lvl++;
                    continue;
                } else if (str[n] == ' ') {
                    n++;
                    header = &str[n];
                    hsz = 1;
                    mode = 1;
                    rc = 1;
                    if (n == (sz - 1)) {
                        *pos += n - start;
                        if (op->header != NULL) {
                            if (state->flags->txtmode) {
                                orgparse_pgrph_end(op, ud);
                                state->flags->txtmode = 0;
                            }
                            op->header(ud, header, hsz, lvl);
                        }
                    }
                } else {
                    mode = 2;
                    rc = 0;
                }
                break;
            case 1:
                if (str[n] == '\n') {
                    mode = 2;
                    *pos += n - start;
                    if (op->header != NULL) {
                        if (state->flags->txtmode) {
                            orgparse_pgrph_end(op, ud);
                            state->flags->txtmode = 0;
                        }
                        op->header(ud, header, hsz, lvl);
                    }
                    rc = 1;
                    break;
                }
                hsz++;
                break;
        }
    }

    return rc;
}
#+END_SRC
** Parse Text
*** Parse Text Callback
Text is defined by what it isn't. If it isn't a header or
code block, it is probably text. For this reason, the text
block is a "last resort".

Anything that is not a header or code block is generally
considered to be a text block. Text can span multiple lines,
and can contain special formatting tags, for things like
*bold* text, **italic** text, and _underlined_ text as well.
In addition, text can also contain links.

When a line is determined to not be anything else (header,
codeblock, aux block, etc), it is sent in to be parsed as
text.

The text block parser will read lines until it hits stuff
that is non-text. Along the way, the text will check for
formatting tags and links on a line by line basis.
**** Main Callback
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_text(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_text(orgparse_state *state)
{
    size_t n;
    size_t start;
    size_t mark;
    int rc;

    orgparse *op;
    const char *str;
    size_t sz;
    void *ud;
    size_t *pos;
    int *mode;
    const char **buf;
    size_t *len;

    op = state->op;
    str = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;
    mode = &state->flags->mode;
    buf = &state->blk;
    len = &state->len;

    rc = 0;
    start = *pos;
    mark = start;

    /* check for end of file */
    if (start == sz) return 0;

    for (n = start; n < sz; n++) {
        if (str[n] == '\n' || n == (sz - 1)) {
            rc = 1;
            if (n == mark) {
                <<handle_newline_logic>>
            } else {
                if (op->text != NULL) {
                    /* +1 includes line break*/
                    op->text(ud,
                            &str[mark],
                            (n - mark) + 1);
                }
            }
            break;
        } else if (parse_aux_check(str, sz, &n)) {
            <<break_and_begin_aux_block>>
        } else if (state->flags->newline) {
            <<newline_begin_paragraph>>
        } else if (parse_bold(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_code(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_ul(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_link(op, str, ud, sz, &n, &mark)) {
            continue;
        }
    }
    *pos += (n - start);
    return rc;
}
#+END_SRC
**** Handling Newline Logic
In org mode, line break characters "\n" can trigger
different behaviors. This is managed via the =newline= flag.

The newline at the end of some text is used to indicate the
end of a line. The text parser reads things a line at a
time, so at that point it is an indicator to break out of
text parser routine.

Newline behavior changes when the character is found without
any other characters. The first newline is considered to
mark the end of a paragraph block. Subsequent newlines are
registered as line breaks.

#+NAME: handle_newline_logic
#+BEGIN_SRC c
if (!state->flags->newline) {
    orgparse_pgrph_end(op, ud);
    state->flags->newline = 1;
} else {
    if (op->newline != NULL) {
        op->newline(ud, NULL, 0);
    }
}
#+END_SRC

Text that begins after a single empty line break is
considered to be a new paragraph. This is determined
by checking to see if the newline flag has been set.

A bug was discovered where the parser skips the first
character of the paragraph. This bug becomes noticeable
when any kind of formatting is used at the beginning of
a paragraph (such as bold text). To mitigate this, the
character pointer (n) moves back one character. While
this may introduce other bugs later (not sure), it does
not seem to break any tests in the current test suite.

#+NAME: newline_begin_paragraph
#+BEGIN_SRC c
state->flags->newline = 0;
orgparse_pgrph_begin(op, ud);
n--; /* go backwards 1 */
#+END_SRC
*** DONE Tag Check
CLOSED: [2019-09-21 Sat 18:39]
This functionality will generically check a line for
matching tags. If a tag is found, the end position is
returned.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int tag_check(const char *txt,
                     size_t sz,
                     char tag,
                     size_t *len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int tag_check(const char *txt,
                     size_t sz,
                     char tag,
                     size_t *len)
{
    size_t n;
    int rc;
    if (sz <= 2) return 0;
    if (txt[0] != tag) return 0;

    rc = 0;
    for (n = 1; n < sz; n++) {
        if (txt[n] == tag) {
            rc = 1;
            *len = n - 1;
            break;
        }
    }
    return rc;
}
#+END_SRC
*** Check and Parse
Checks AND parses particular tag.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int check_and_parse(orgparse *op,
                           const char *str,
                           void *ud,
                           size_t sz,
                           size_t *pos,
                           size_t *mark,
                           char tag,
                           orgparse_text f);
#+END_SRC
Setting the =mark= and =pos= variables for mark and position
took some trial and error to get right.
#+NAME: functions
#+BEGIN_SRC c
static int check_and_parse(orgparse *op,
                           const char *str,
                           void *ud,
                           size_t sz,
                           size_t *pos,
                           size_t *mark,
                           char tag,
                           orgparse_text f)
{
    size_t n, m;
    int rc;
    size_t len;

    n = *pos;
    m = *mark;
    rc = 0;
    len = 0;

    if (tag_check(&str[n],
                  sz - m,
                  tag,
                  &len)) {
        if (op->text != NULL && n != m) {
            op->text(ud, &str[m], n - m);
        }
        if (f != NULL) {
            f(ud, &str[n + 1], len);
        }
        n += len + 2;
        m = n;
        /* commenting this out makes the tests pass */
        /* if (n < sz && str[n] == '\n') n--; */
        *pos = n;
        *mark = m;
        rc = 1;
    }

    return rc;
}
#+END_SRC
*** Parse Bold
This will check and parse *bold* text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_bold(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_bold(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '*',
                           op->bold);
}
#+END_SRC
*** Parse Code.
This will check and parse =code= text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_code(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_code(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '=',
                           op->code);
}
#+END_SRC
*** Parse Underline.
This will check and parse =underline= text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_ul(orgparse *op,
                    const char *str,
                    void *ud,
                    size_t sz,
                    size_t *pos,
                    size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_ul(orgparse *op,
                    const char *str,
                    void *ud,
                    size_t sz,
                    size_t *pos,
                    size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '_',
                           op->underline);
}
#+END_SRC
*** Parse Link
**** Top Level Function
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_link(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_link(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    int rc;
    const char *link;
    size_t link_sz;
    const char *name;
    size_t name_sz;
    size_t len;
    size_t n, m;

    rc = check_link(str, *pos, sz);

    if (!rc) return 0;

    link_sz = 0;
    name_sz = 0;
    len = 0;

    n = *pos;
    m = *mark;

    extract_link(str, n, sz,
                 &link, &link_sz,
                 &name, &name_sz,
                 &len);

    if (op->text != NULL && n != m) {
        op->text(ud, &str[m], n - m);
    }

    if (op->link != NULL) {
        op->link(ud, link, link_sz, name, name_sz);
    }

    n += len + 2;
    m = n;
    if (n < sz && str[n] == '\n') n--;

    *pos = n;
    *mark = m;

    return 1;
}
#+END_SRC
**** Check For Link
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int check_link(const char *str,
                      size_t pos,
                      size_t sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int check_link(const char *str,
                      size_t pos,
                      size_t sz)
{
    size_t n;

    if ((pos - sz) < 5) return 0;

    if (str[pos] != '[' || str[pos+1] != '[') return 0;

    sz -= 1; /* for lookahead */
    pos += 2;

    for (n = pos; n < sz; n++) {
        if (str[n] == '\n') return 0;
        if (str[n] == ']' && str[n + 1] == ']') return 1;
    }

    return 0;
}
#+END_SRC
**** Extract Link
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void extract_link(const char *str,
                         size_t pos,
                         size_t sz,
                         const char **plink,
                         size_t *link_sz,
                         const char **pname,
                         size_t *name_sz,
                         size_t *len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void extract_link(const char *str,
                         size_t pos,
                         size_t sz,
                         const char **plink,
                         size_t *link_sz,
                         const char **pname,
                         size_t *name_sz,
                         size_t *len)
{
    size_t off;
    size_t n;
    const char *link;
    size_t link_size;
    const char *name;
    size_t name_size;
    size_t tmp;
    size_t start;


    sz -= 1; /* for lookahead */

    start = pos;
    pos += 2;

    off = 2;
    name_size = 0;
    link_size = 0;
    tmp = 0;
    link = NULL;
    name = NULL;
    link = &str[pos];
    for(n = pos; n < sz; n++) {
        off++;
        tmp++;
        if(str[n] == ']' && str[n + 1] == '[') {
            link_size = tmp - 1;
            tmp = 0;
            name = &str[n + 2];
            n++;
            off++;
        } else if(str[n] == ']' && str[n + 1] == ']') {
            name_size = tmp - 1;
            if(name == NULL) { /* name not set, assume type 2 link */
                link_size = name_size;
                name = link;
            }
            off++;
            break;
        }
    }
    *name_sz = name_size;
    *pname = name;
    *link_sz = link_size;
    *plink = link;
    *len = n - start;
}
#+END_SRC
** Parse Comment
Any thing that starts with '# ' (hash + space) is considered
to be a comment, and the line will be ignored.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_comment(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_comment(orgparse_state *state)
{
    size_t start;
    size_t n;
    const char *txt;
    size_t sz;
    size_t *pos;

    txt = state->txt;
    sz = state->sz;
    pos = &state->pos;

    if ((sz - *pos) < 2) return 0;
    if (txt[*pos] != '#') return 0;
    if (txt[*pos + 1] != ' ') return 0;

    start = *pos;

    for (n = start; n < sz; n++) {
        if (txt[n] == '\n') break;
    }

    *pos += (n - start);

    return 1;
}
#+END_SRC
** Parse Command
A 'command' in org mode refers to any line that starts with
'#+'. After this, a string of alphanumeric non-space
characters creates the command name. Following this is an
arbitray number of spaces, followed by the command string.

The =parse_cmd= function will parse and extract the
command, and command string (assuming it is indeed
a command).

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_cmd(const char *str,
                     size_t sz,
                     const char **cmd,
                     size_t *cmd_len,
                     const char **cmdstr,
                     size_t *cmdstr_len,
                     size_t *total_len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_cmd(const char *str,
                     size_t sz,
                     const char **cmd,
                     size_t *cmd_len,
                     const char **cmdstr,
                     size_t *cmdstr_len,
                     size_t *total_len)
{
    size_t n;
    const char *pcmdstr;
    const char *pcmd;
    size_t len;
    int mode;
    int rc;

    if (sz < 3) return 0;
    if (str[0] != '#') return 0;
    if (str[1] != '+') return 0;
    if (str[2] == ' ') return 0;

    rc = 0;

    mode = 0;

    pcmd = &str[2];
    pcmdstr = NULL;
    len = 0;

    /* zero out lengths */

    *total_len = 0;
    *cmdstr_len = 0;
    *cmd_len = 0;

    for (n = 2; n < sz; n++) {
        if (str[n] == '\n') {
            *cmdstr_len = len;
            if (mode == 0) {
                *cmd_len = len;
                *cmdstr_len = 0;
                rc = 1;
            }
            break;
        }
        switch (mode) {
            case 0: /* command string */
                if (str[n] == ' ') {
                    mode = 1;
                    *cmd_len = len;
                    len = 0;
                    rc = 1;
                    break;
                }
                len++;
                break;
            case 1:
                if (str[n] != ' ') {
                    mode = 2;
                    len = 1;
                    pcmdstr = &str[n];
                }
                break;
            case 2:
                len++;
                break;
        }
    }

    *cmdstr = pcmdstr;
    *cmd = pcmd;
    *total_len = n * rc;

    return rc;
}
#+END_SRC
** Parse Codeblock
A codeblock is a set of lines smooshed between
'#+BEGIN_SRC' and '#+END_SRC' tags.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_codeblock(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_codeblock(orgparse_state *state)
{
    int rc;
    size_t start;
    size_t cmdlen;
    size_t cmdstrlen;
    const char *cmd;
    const char *cmdstr;
    size_t totallen;
    size_t n;
    int new_block;

    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t *pos;
    int *mode;
    const char **blk;
    size_t *blklen;

    op = state->op;
    txt = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;
    mode = &state->flags->mode;
    blk = &state->blk;
    blklen = &state->len;

    start = *pos;
    cmdlen = 0;
    cmdstrlen = 0;
    totallen = 0;
    rc = parse_cmd(&txt[start],
                   sz,
                   &cmd,
                   &cmdlen,
                   &cmdstr,
                   &cmdstrlen,
                   &totallen);
    new_block = 0;

    if (rc) {
        if (*mode  == 0) {
            if (!strncmp(cmd, "BEGIN_SRC", cmdlen)) {
                *pos += totallen;
                *blk = &txt[*pos + 1];
                *blklen = 0;
                *mode = 1;
                new_block = 1;
            } else {
                /* another command, not a codeblock */
                rc = 0;
            }
        } else if (*mode == 1) {
            if (!strncmp(cmd, "END_SRC", cmdlen)) {
                *pos += totallen;
                *mode = 0;
                if (op->codeblock != NULL) {
                    op->codeblock(ud, *blk, *blklen - 1);
                }
                *blk = NULL;
                *blklen = 0;
            }
        }
    }

    /* Read a line */
    if (*mode == 1 && !new_block) {
        rc = 1;
        for (n = start; n < sz; n++) {
            if (txt[n] == '\n') break;
        }
        *pos += (n - start);
        *blklen += (n - start) + 1;
    }

    return rc;
}
#+END_SRC
** Parse Name
Parses a "#+NAME" command.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_name(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_name(orgparse_state *state)
{
    int rc;
    size_t start;
    size_t cmdlen;
    size_t cmdstrlen;
    const char *cmd;
    const char *cmdstr;
    size_t totallen;

    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t *pos;

    op = state->op;
    txt = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;

    start = *pos;
    cmdlen = 0;
    cmdstrlen = 0;
    totallen = 0;
    rc = parse_cmd(&txt[start],
                   sz,
                   &cmd,
                   &cmdlen,
                   &cmdstr,
                   &cmdstrlen,
                   &totallen);
    if (rc) {
        if (!strncmp(cmd, "NAME:", cmdlen)) {
            if (op->name != NULL) {
                op->name(ud, cmdstr, cmdstrlen);
            }
            *pos += totallen;
        } else rc = 0;
    }

    return rc;
}
#+END_SRC
** Parsing an Aux Block
An aux block is anything inside of a '@!' and '!@'.
For WeeWiki, the idea here is to execute janet code for
dynamic page content. Aux blocks can be both in-line and
multiline. They start out inside of a text block, but have
their own mode for multi-line processing (similar to code
blocks).
*** Beginning a Block
**** Checking for an Aux Block
An aux block can be started at anytime inside of a text
block. The parsing process here must check for any '@!'
roaming around. This is wrapped inside of a function called
=parse_aux_check=. It is called inside of =parse_text=.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_aux_check(const char *str,
                           size_t sz,
                           size_t *pos);
#+END_SRC
At one point, this once also processed the aux block code,
but the function ended up taking too many arguments! Now
it only checks.
#+NAME: functions
#+BEGIN_SRC c
static int parse_aux_check(const char *str,
                           size_t sz,
                           size_t *pos)
{
    size_t n;

    n = *pos;

    if ((sz - n) < 4) return 0;
    if (str[n] != '@') return 0;
    if (str[n + 1] != '!') return 0;

    return 1;
}
#+END_SRC
**** Breaking Out of The Loop
If indeed an aux block has been found, the parsing routine
will immediately break out of the loop and set itself
up to be in aux block mode (mode 2). Any text up to this
point is processed as well.

Return values aren't really being used right now, but
the return value is being set to be 0 (false) to indicate
that the the text has been short-circuited by an aux block.

The code below is done inside of the =parse_text= function.
#+NAME: break_and_begin_aux_block
#+BEGIN_SRC c
if (op->text != NULL && n != mark) {
    op->text(ud, &str[mark], n - mark);
}

if (state->flags->newline) {
    state->flags->newline = 0;
    orgparse_pgrph_begin(op, ud);
}

*mode = 2;
*len = 0;
*buf = &str[n + 2];
rc = 0;
break;
#+END_SRC
*** Ending it
Once the parse state machine is set to be in aux block mode,
it can only be ended by finding a matching '!@' tag.
**** Do I end?
The only way a aux block ends is with the magic tag '!@'.
This is checked with the function =parse_aux_doiend=.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_aux_doiend(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_aux_doiend(orgparse_state *state)
{
    if ((state->sz - state->pos) < 2) return 0;
    return (state->txt[state->pos] == '!' &&
            state->txt[state->pos + 1] == '@');
}
#+END_SRC
**** Ending The Aux Block
#+NAME: end_the_aux_block
#+BEGIN_SRC c
state->flags->mode = 0;
state->pos++;
if (state->op->aux != NULL) {
    state->op->aux(state->ud, state->blk, state->len - 1);
}
<<handle_auxblock_endofline>>
#+END_SRC
An edge case to handle: what happens when an aux block is at
the end of a line? When this happens, the parser absorbs the
newline character. If this doesn't happen, the text parser
adds an extra newline.
#+NAME: handle_auxblock_endofline
#+BEGIN_SRC c
if ((state->pos + 1) < state->sz &&
    state->txt[state->pos + 1] == '\n') {
    state->pos++;
}
#+END_SRC
**** Adding to aux line
While in aux block mode, the character block length is
increased one character at a time.
#+NAME: increment_aux_line
#+BEGIN_SRC c
state->len++;
#+END_SRC
** Parse Title
Parses the =TITLE= commmand.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_title(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_title(orgparse_state *state)
{
    int rc;
    size_t start;
    size_t cmdlen;
    size_t cmdstrlen;
    const char *cmd;
    const char *cmdstr;
    size_t totallen;


    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t *pos;

    op = state->op;
    txt = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;

    start = *pos;
    cmdlen = 0;
    cmdstrlen = 0;
    totallen = 0;
    rc = parse_cmd(&txt[start],
                   sz,
                   &cmd,
                   &cmdlen,
                   &cmdstr,
                   &cmdstrlen,
                   &totallen);
    if (rc) {
        if (!strncmp(cmd, "TITLE:", cmdlen)) {
            if (op->title != NULL) {
                op->title(ud, cmdstr, cmdstrlen);
            }
            *pos += totallen;
        }
    }

    return rc;
}
#+END_SRC
