#+TITLE: Orgparse
Orgparse is a portable org-mode parser, written in ANSI C.
* Top Files
The entirety of orgparse is contained in a single header
file.

Defining =ORGPARSE_IMPLEMENTATION= will include the
functions and should only happen once per file.

Defining =ORPARSE_TEST= will include the test program.
#+NAME: orgparse.h
#+BEGIN_SRC c :tangle orgparse.h
#ifndef ORGPARSE_H
#define ORGPARSE_H
<<typedefs>>
#ifdef ORGPARSE_IMPLEMENTATION
<<structs>>
#endif
<<funcdefs>>
#ifdef ORGPARSE_IMPLEMENTATION
<<static_funcdefs>>
<<functions>>
#endif
#ifdef ORGPARSE_TEST
<<test_program>>
#endif
#endif
#+END_SRC
* Test Parser
This test program can be run inside of =main=, and is
designed to be run as a command line program.
** Top Level Program
#+NAME: funcdefs
#+BEGIN_SRC c
#ifdef ORGPARSE_TEST
int orgparse_test(int argc, char *argv[]);
#endif
#+END_SRC
#+NAME: test_program
#+BEGIN_SRC c
<<test_callbacks>>
static void setup_orgparse(orgparse *op)
{
    <<setup_test_callbacks>>
}
int orgparse_test_parser(int argc, char *argv[])
{
    orgparse op;
    FILE *fp;
    char *buf;
    size_t sz;
    if (argc == 1) {
        fprintf(stderr, "Usage: %s file.org\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[1], "r");
    if (fp == NULL) {
        fprintf(stderr,
                "Could not open %s for reading.\n",
                argv[1]);
        return 1;
    }
    fseek(fp, 0, SEEK_END);
    sz = ftell(fp) + 1;
    buf = calloc(1, sz);
    fseek(fp, 0, SEEK_SET);
    fread(buf, 1, sz, fp);
    orgparse_init(&op);
    setup_orgparse(&op);
    orgparse_run(&op, buf, sz, NULL);
    free(buf);
    return 0;
}
#+END_SRC
** Test Callbacks
*** Header
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_header(void *ud,
                        const char *h,
                        size_t sz,
                        int lvl)
{
    printf("header: '");
    fwrite(h, 1, sz, stdout);
    printf("', lvl: %d\n", lvl);
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_header(op, test_header);
#+END_SRC
*** Text
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_text(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("text: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_text(op, test_text);
#+END_SRC
*** Bold
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_bold(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("bold: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_bold(op, test_bold);
#+END_SRC
*** Code
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_code(void *ud,
                      const char *str,
                      size_t sz)
{
    printf("code: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_code(op, test_code);
#+END_SRC
*** Underline
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_uline(void *ud,
                       const char *str,
                       size_t sz)
{
    printf("underline: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_underline(op, test_uline);
#+END_SRC
*** Newline
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_newline(void *ud,
                         const char *str,
                         size_t sz)
{
    printf("newline\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_newline(op, test_newline);
#+END_SRC
*** Codeblock
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_codeblock(void *ud,
                           const char *str,
                           size_t sz)
{
    printf("codeblock: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_codeblock(op, test_codeblock);
#+END_SRC
*** Name
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_name(void *ud,
                           const char *str,
                           size_t sz)
{
    printf("name: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_name(op, test_name);
#+END_SRC
*** Aux Block
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_aux(void *ud,
                     const char *str,
                     size_t sz)
{
    printf("aux: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_aux(op, test_aux);
#+END_SRC
*** Title
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_title(void *ud,
                       const char *str,
                       size_t sz)
{
    printf("title: '");
    fwrite(str, 1, sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_title(op, test_title);
#+END_SRC
*** Link
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_link(void *ud,
                      const char *link,
                      size_t link_sz,
                      const char *name,
                      size_t name_sz)
{
    printf("link_ref: '");
    fwrite(link, 1, link_sz, stdout);
    printf("'', '");
    fwrite(name, 1, name_sz, stdout);
    printf("'\n");
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_link(op, test_link);
#+END_SRC
*** Paragraph
#+NAME: test_callbacks
#+BEGIN_SRC c
static void test_pgrph(void *ud, int mode)
{
    if (mode) {
        printf("PARAGRAPH END\n");
    } else {
        printf("PARAGRAPH BEGIN\n");
    }
}
#+END_SRC
#+NAME: setup_test_callbacks
#+BEGIN_SRC c
orgparse_set_pgrph(op, test_pgrph);
#+END_SRC
* Test Suite
A test suite is used to ensure that things function the way
they are supposed to.
** Top
#+NAME: funcdefs
#+BEGIN_SRC c
#ifdef ORGPARSE_TEST
int orgparse_test_suite(void);
#endif
#+END_SRC
#+NAME: test_program
#+BEGIN_SRC c
typedef struct {
    const char *name;
    int (*test)(void);
} test_entry;

enum {
    OK,
    FAIL,
    IGNORE
};

<<tests>>

test_entry Tests[] =
{
    <<test_entries>>
};

int orgparse_test_suite(void)
{
    int n;
    int ntests;
    test_entry *e;
    int rc;
    int nerr;

    ntests = sizeof(Tests)/sizeof(*Tests);
    rc = 0;
    nerr = 0;

    for(n = 0; n < ntests; n++) {
        e = &Tests[n];
        rc = e->test();
        printf("[%d/%d] %s: ", n + 1, ntests, e->name);
        switch (rc) {
            case OK:
                printf("OK\n");
                break;
            case FAIL:
                nerr++;
                printf("FAIL\n");
                break;
            default:
                printf("???\n");
                break;
        }
    }

    if (nerr) {
        printf("\nTest suite failed with %d error(s)\n", nerr);
        rc = 1;
    } else {
        printf("\nTest suite successful\n");
        rc = 0;
    }
    return rc;
}
#+END_SRC
** Tests
*** Template Test
Just to get things started. A boilerpalte test that
returns "okay".
#+NAME: test_entries
#+BEGIN_SRC c
{"Template Test", test_foo},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
static int test_foo(void)
{
    return OK;
}
#+END_SRC
*** Extra Newline at Ending Aux Block
This is a particular edge case that happens when an aux
block ends up at the end of a text block. It will go and
print an extra newline statement.
#+NAME: test_entries
#+BEGIN_SRC c
{"Extra newline at ending aux block", test_ending_auxblock},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
static void ending_auxblock_newline(void *ud,
                                    const char *str,
                                    size_t sz)
{
    int *nl;
    nl = ud;
    *nl = (*nl) + 1;
}

static int test_ending_auxblock(void)
{
    orgparse op;
    int nl;
    int rc;

    nl = 0;
    orgparse_init(&op);
    orgparse_set_newline(&op, ending_auxblock_newline);
    orgparse_run(&op, "@! some text !@\n\none.", 23, &nl);
    rc = OK;
    if (nl != 1) {
        printf("%d newlines when it should have been 1\n",
               nl);
        rc = FAIL;
    }
    return rc;
}
#+END_SRC
*** Text Before Code Block
Text before a block causes a code block to glitchy by one.
#+NAME: test_entries
#+BEGIN_SRC c
{"Text before codeblock", test_text_before_blk},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    const char *code;
    size_t sz;
    int found_codeblock;
    int off_by_one;
} tbb_d;

static void tbb_codeblock(void *ud,
                          const char *str,
                          size_t sz)
{
    tbb_d *tbb;
    tbb = ud;

    tbb->code = str;
    tbb->sz = sz;
    tbb->found_codeblock = 1;
}

static void tbb_text(void *ud,
                     const char *str,
                     size_t sz)
{
    tbb_d *tbb;
    tbb = ud;

    if (str[0] == '+') {
        tbb->off_by_one = 1;
    }
}

static int test_text_before_blk(void)
{
    orgparse op;
    tbb_d tbb;
    const char *str =
        "one.\n"
        "#+NAME: block\n"
        "#+BEGIN_SRC text\n"
        "this is a codeblock.\n"
        "#+END_SRC";
    int rc;

    tbb.sz = 0;
    tbb.code = NULL;
    tbb.found_codeblock = 0;
    tbb.off_by_one = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_codeblock(&op, tbb_codeblock);
    orgparse_set_text(&op, tbb_text);
    orgparse_run(&op, str, strlen(str), &tbb);

    if (!tbb.found_codeblock) {
        printf("Codeblock not found\n");
        rc = FAIL;
    }

    if (tbb.off_by_one) {
        printf("Codeblock parser is off by one (+BEGIN)\n");
        rc = FAIL;
    }

    return rc;
}
#+END_SRC
*** Invalid Paragraph Start
This happens at the end of a file with any non-text thing
(such as a header). While that bug has been fixed, a new
bug has occured where a header does not get parsed if there
is no newline. Trying to get to the bottom of that as well
now.
#+NAME: test_entries
#+BEGIN_SRC c
{"Invalid Paragraph Start", test_invalid_pgrph},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int found;
    int headers;
} ip_d;

static void ip_pgrph(void *ud, int mode)
{
    ip_d *ip;
    ip = ud;
    ip->found++;
}

static void ip_header(void *ud, const char *str, size_t sz, int lvl)
{
    ip_d *ip;
    ip = ud;
    ip->headers++;
}

static int test_invalid_pgrph(void)
{
    orgparse op;
    int rc;
    ip_d ip;
    const char *str = "* A\n* B";

    ip.found = 0;
    ip.headers = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_pgrph(&op, ip_pgrph);
    orgparse_set_header(&op, ip_header);
    orgparse_run(&op, str, strlen(str), &ip);

    if (ip.found) {
        printf("Found %d paragraph calls\n", ip.found);
        rc = FAIL;
    }

    if (ip.headers != 2) {
        printf("Found %d headers, expected 2\n",
               ip.headers);
    }

    return rc;
}
#+END_SRC
*** New paragraph block after header
For some reason, a new paragraph block will not start in
a second header. This test will make sure it passes.
#+NAME: test_entries
#+BEGIN_SRC c
{"New Paragraph After Block Header", test_new_pgrph},
#+END_SRC
#+NAME: tests
#+BEGIN_SRC c
typedef struct {
    int found;
    int headers;
} np_d;

static void np_pgrph(void *ud, int mode)
{
    np_d *np;
    np = ud;
    if (mode == 0) np->found++;
}

static void np_header(void *ud, const char *str, size_t sz, int lvl)
{
    np_d *np;
    np = ud;
    np->headers++;
}

static int test_new_pgrph(void)
{
    orgparse op;
    int rc;
    np_d np;
    const char *str = "* A\n123\n* B\n456";

    np.found = 0;
    np.headers = 0;

    rc = OK;

    orgparse_init(&op);
    orgparse_set_pgrph(&op, np_pgrph);
    orgparse_set_header(&op, np_header);
    orgparse_run(&op, str, strlen(str), &np);

    if (np.found != 2) {
        printf("Found %d paragraph call(s)\n", np.found);
        printf("Expected 2\n");
        rc = FAIL;
    }

    if (np.headers != 2) {
        printf("Found %d headers, expected 2\n",
               np.headers);
    }

    return rc;
}
#+END_SRC
* Main Interface
Orgparse is a callback interface. These functions will
handle the various parts of the org file.
** Struct
*** Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct orgparse orgparse;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct orgparse {
    <<interface>>
};
#+END_SRC
*** Init
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_init(orgparse *op);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_init(orgparse *op)
{
    <<init>>
}
#+END_SRC
** Callbacks
All callbacks have the same first 3 arguments: a generic
pointer, the string, and the length of the string.
*** Header
An org header. In addition to the header name, also supplies
the header level.
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_header)(void *,
                                const char *,
                                size_t,
                                int);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_header header;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->header = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_header(orgparse *op, orgparse_header f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_header(orgparse *op, orgparse_header f)
{
    op->header = f;
}
#+END_SRC
*** Text
This function is anything that isn't formatted text.
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_text)(void *,
                              const char *,
                              size_t);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_text text;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->text = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_text(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_text(orgparse *op, orgparse_text f)
{
    op->text = f;
}
#+END_SRC
*** Code
Text that is defined inside the =codeblock= tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text code;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->code = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_code(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_code(orgparse *op, orgparse_text f)
{
    op->code = f;
}
#+END_SRC
*** Bold
Text that is defined inside the *bold* tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text bold;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->bold = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_bold(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_bold(orgparse *op, orgparse_text f)
{
    op->bold = f;
}
#+END_SRC
*** Italic
Text that is defined inside the **italic** tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text italic;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->italic = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_italic(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_italic(orgparse *op, orgparse_text f)
{
    op->italic = f;
}
#+END_SRC
*** Underline
Text that is contained inside the _underline_ tags.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text underline;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->underline = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_underline(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_underline(orgparse *op, orgparse_text f)
{
    op->underline = f;
}
#+END_SRC
*** Code Block
Text inside of a code block.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text codeblock;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->codeblock = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_codeblock(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_codeblock(orgparse *op, orgparse_text f)
{
    op->codeblock = f;
}
#+END_SRC
*** Aux
A special non-org tag, used for interpolated code in tags !@
and @!.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text aux;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->aux = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_aux(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_aux(orgparse *op, orgparse_text f)
{
    op->aux = f;
}
#+END_SRC
*** Newline
The newline callback gets called anytime there is an empty
line, which means an explicit line break is needed.
For convenience, the =orgparse_text= callback is used,
though the arguments will be unused and set to =NULL=.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text newline;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->newline = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_newline(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_newline(orgparse *op, orgparse_text f)
{
    op->newline = f;
}
#+END_SRC
*** Name
Handles a 'NAME' command.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text name;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->name = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_name(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_name(orgparse *op, orgparse_text f)
{
    op->name = f;
}
#+END_SRC
*** Title
Handles a titlecommand.
#+NAME: interface
#+BEGIN_SRC c
orgparse_text title;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->title = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_title(orgparse *op, orgparse_text f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_title(orgparse *op, orgparse_text f)
{
    op->title = f;
}
#+END_SRC
*** Link
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_link)(void *,
                              const char *,
                              size_t,
                              const char *,
                              size_t);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_link link;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->link = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_link(orgparse *op, orgparse_link f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_link(orgparse *op, orgparse_link f)
{
    op->link = f;
}
#+END_SRC
*** Paragraph
The pargraph callback gets called anytime a paragraph block
starts or end. For HTML generation, this will be in charge
of generating p-tags.

A paragraph starts when a new text block begins, and ends
with a line break, or major mode change (such as for a code
block or header).
#+NAME: typedefs
#+BEGIN_SRC c
typedef void (*orgparse_pgrph)(void *, int);
#+END_SRC
#+NAME: interface
#+BEGIN_SRC c
orgparse_pgrph pgrph;
#+END_SRC
#+NAME: init
#+BEGIN_SRC c
op->pgrph = NULL;
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_set_pgrph(orgparse *op, orgparse_pgrph f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_set_pgrph(orgparse *op, orgparse_pgrph f)
{
    op->pgrph = f;
}
#+END_SRC

A paragraph begins with =orgparse_pgrph_begin=.
A paragraph ends with =orgparse_pgrph_end=.
Note that neither of these functions actually check to see
if they are *supposed* to be beginning or ending. That logic
is done elsewhere.

#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_pgrph_begin(orgparse *op, void *ud);
void orgparse_pgrph_end(orgparse *op, void *ud);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_pgrph_begin(orgparse *op, void *ud)
{
    if (op->pgrph != NULL) {
        op->pgrph(ud, 0);
    }
}

void orgparse_pgrph_end(orgparse *op, void *ud)
{
    if (op->pgrph != NULL) {
        op->pgrph(ud, 1);
    }
}
#+END_SRC
* Parsing
** Orgparse State Struct
All mutable orgparse data is contained inside of a struct
called =orgparse_state=, which gets instantiated with every
call to =orgparse_run=. This allows =orgparse_run= to be
re-entrant, which is a needed requirement in order for
weewiki's scripting capabilities to really work.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct orgparse_state orgparse_state;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct orgparse_state {
    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t pos;
    int mode;
    int pmode;
    int txtmode;
    const char *blk;
    size_t len;
    int newline;
};
#+END_SRC
** Top Level Parse (orgparse_run)
Parsing is done using the function =orgparse_run=.
All mutable variables are declared locally, so it should
be feasible to run nested calls to this function.

=orgparse_run= expects a properly intialized + set instance
of =orgparse=, a text block, the text block size, and any
user data.
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_run(orgparse *op,
                  const char *txt,
                  size_t sz,
                  void *ud);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_run(orgparse *op,
                  const char *txt,
                  size_t sz,
                  void *ud)
{
    orgparse_state state;
    state.op = op;
    state.txt = txt;
    state.sz = sz;
    state.pos = 0;
    state.mode = 0;
    state.pmode = -1;
    state.txtmode = 0;
    state.len = 0;
    state.ud = ud;
    state.blk = NULL;

    orgparse_state_run(&state);
}
#+END_SRC
#+NAME: funcdefs
#+BEGIN_SRC c
void orgparse_state_run(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void orgparse_state_run(orgparse_state *state)
{
    int txtmode;

    for (state->pos = 0; state->pos < state->sz; state->pos++) {
        txtmode = 0;
        if (state->mode == 0) {
            if (parse_comment(state)) {
                continue;
            }
            if (parse_codeblock(state)) {
                continue;
            } else if (parse_header(state)) {
                continue;
            } else if (parse_name(state)) {
                continue;
            } else if (parse_title(state)) {
                continue;
            } else {
                if (!state->txtmode) {
                    if (state->pos < (state->sz - 1)) {
                        orgparse_pgrph_begin(state->op,
                                            state->ud);
                        state->newline = 0;
                    }
                }
                txtmode = 1;
                parse_text(state);
            }
        } else if (state->mode == 1) {
            parse_codeblock(state);
        } else if (state->mode == 2) {
            if (state->txtmode) txtmode = 1;
            if (parse_aux_doiend(state)) {
                <<end_the_aux_block>>
            } else {
                <<increment_aux_line>>
            }
        }
        state->txtmode = txtmode;
    }
}
#+END_SRC
** Parse Header
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_header(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_header(orgparse_state *state)
{
    const char *header;
    size_t n;
    size_t start;
    int mode;
    int lvl;
    size_t hsz;
    int rc;

    orgparse *op;
    const char *str;
    size_t sz;
    void *ud;
    size_t *pos;

    op = state->op;
    str = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;

    if(sz - *pos < 2) return 0;
    if (str[*pos] != '*') return 0;

    start = *pos;
    mode = 0;
    lvl = 0;
    rc = 0;
    for (n = start; n < sz; n++) {
        if (mode == 2) break;
        switch (mode) {
            case 0:
                if (str[n] == '*') {
                    lvl++;
                    continue;
                } else if (str[n] == ' ') {
                    n++;
                    header = &str[n];
                    hsz = 1;
                    mode = 1;
                    rc = 1;
                    if (n == (sz - 1)) {
                        *pos += n - start;
                        if (op->header != NULL) {
                            if (state->txtmode) {
                                orgparse_pgrph_end(op, ud);
                            }
                            op->header(ud, header, hsz, lvl);
                        }
                    }
                } else {
                    mode = 2;
                    rc = 0;
                }
                break;
            case 1:
                if (str[n] == '\n') {
                    mode = 2;
                    *pos += n - start;
                    if (op->header != NULL) {
                        if (state->txtmode) {
                            orgparse_pgrph_end(op, ud);
                        }
                        op->header(ud, header, hsz, lvl);
                    }
                    rc = 1;
                    break;
                }
                hsz++;
                break;
        }
    }

    return rc;
}
#+END_SRC
** Parse Text
*** Parse Text Callback
Text is defined by what it isn't. If it isn't a header or
code block, it is probably text. For this reason, the text
block is a "last resort".

Anything that is not a header or code block is generally
considered to be a text block. Text can span multiple lines,
and can contain special formatting tags, for things like
*bold* text, **italic** text, and _underlined_ text as well.
In addition, text can also contain links.

When a line is determined to not be anything else (header,
codeblock, aux block, etc), it is sent in to be parsed as
text.

The text block parser will read lines until it hits stuff
that is non-text. Along the way, the text will check for
formatting tags and links on a line by line basis.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_text(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_text(orgparse_state *state)
{
    size_t n;
    size_t start;
    size_t mark;
    int rc;

    orgparse *op;
    const char *str;
    size_t sz;
    void *ud;
    size_t *pos;
    int *mode;
    const char **buf;
    size_t *len;

    op = state->op;
    str = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;
    mode = &state->mode;
    buf = &state->blk;
    len = &state->len;

    rc = 0;
    start = *pos;
    mark = start;

    /* check for end of file */
    if (start == (sz - 1)) return 0;

    for (n = start; n < sz; n++) {
        if (str[n] == '\n' || n == (sz - 1)) {
            rc = 1;
            if (n == mark) {
                /* if (!state->newline) { */
                /*     orgparse_pgrph_end(op, ud); */
                /*     state->newline = 1; */
                /* } else { */
                /*     if (op->newline != NULL) { */
                /*         op->newline(ud, NULL, 0); */
                /*     } */
                if (op->newline != NULL) {
                    op->newline(ud, NULL, 0);
                }
            } else {
                if (op->text != NULL) {
                    /* +1 includes line break*/
                    op->text(ud,
                            &str[mark],
                            (n - mark) + 1);
                }
            }
            break;
        /* } else if (state->newline) { */
        /*     state->newline = 0; */
        /*     orgparse_pgrph_begin(op, ud); */
        } else if (parse_aux_check(str, sz, &n)) {
            <<break_and_begin_aux_block>>
        } else if (parse_bold(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_code(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_ul(op, str, ud, sz, &n, &mark)) {
            continue;
        } else if (parse_link(op, str, ud, sz, &n, &mark)) {
            continue;
        }
    }
    *pos += (n - start);
    return rc;
}
#+END_SRC
*** DONE Tag Check
CLOSED: [2019-09-21 Sat 18:39]
This functionality will generically check a line for
matching tags. If a tag is found, the end position is
returned.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int tag_check(const char *txt,
                     size_t sz,
                     char tag,
                     size_t *len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int tag_check(const char *txt,
                     size_t sz,
                     char tag,
                     size_t *len)
{
    size_t n;
    int rc;
    if (sz <= 2) return 0;
    if (txt[0] != tag) return 0;

    rc = 0;
    for (n = 1; n < sz; n++) {
        if (txt[n] == tag) {
            rc = 1;
            *len = n - 1;
            break;
        }
    }
    return rc;
}
#+END_SRC
*** Check and Parse
Checks AND parses particular tag.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int check_and_parse(orgparse *op,
                           const char *str,
                           void *ud,
                           size_t sz,
                           size_t *pos,
                           size_t *mark,
                           char tag,
                           orgparse_text f);
#+END_SRC
Setting the =mark= and =pos= variables for mark and position
took some trial and error to get right.
#+NAME: functions
#+BEGIN_SRC c
static int check_and_parse(orgparse *op,
                           const char *str,
                           void *ud,
                           size_t sz,
                           size_t *pos,
                           size_t *mark,
                           char tag,
                           orgparse_text f)
{
    size_t n, m;
    int rc;
    size_t len;

    n = *pos;
    m = *mark;
    rc = 0;
    len = 0;

    if (tag_check(&str[n],
                  sz - m,
                  tag,
                  &len)) {
        if (op->text != NULL && n != m) {
            op->text(ud, &str[m], n - m);
        }
        if (f != NULL) {
            f(ud, &str[n + 1], len);
        }
        n += len + 2;
        m = n;
        if (n < sz && str[n] == '\n') n--;
        *pos = n;
        *mark = m;
        rc = 1;
    }

    return rc;
}
#+END_SRC
*** Parse Bold
This will check and parse *bold* text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_bold(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_bold(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '*',
                           op->bold);
}
#+END_SRC
*** Parse Code.
This will check and parse =code= text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_code(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_code(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '=',
                           op->code);
}
#+END_SRC
*** Parse Underline.
This will check and parse =underline= text.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_ul(orgparse *op,
                    const char *str,
                    void *ud,
                    size_t sz,
                    size_t *pos,
                    size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_ul(orgparse *op,
                    const char *str,
                    void *ud,
                    size_t sz,
                    size_t *pos,
                    size_t *mark)
{
    return check_and_parse(op,
                           str,
                           ud,
                           sz,
                           pos,
                           mark,
                           '_',
                           op->underline);
}
#+END_SRC
*** Parse Link
**** Top Level Function
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_link(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_link(orgparse *op,
                      const char *str,
                      void *ud,
                      size_t sz,
                      size_t *pos,
                      size_t *mark)
{
    int rc;
    const char *link;
    size_t link_sz;
    const char *name;
    size_t name_sz;
    size_t len;
    size_t n, m;

    rc = check_link(str, *pos, sz);

    if (!rc) return 0;

    link_sz = 0;
    name_sz = 0;
    len = 0;

    n = *pos;
    m = *mark;

    extract_link(str, n, sz,
                 &link, &link_sz,
                 &name, &name_sz,
                 &len);

    if (op->text != NULL && n != m) {
        op->text(ud, &str[m], n - m);
    }

    if (op->link != NULL) {
        op->link(ud, link, link_sz, name, name_sz);
    }

    n += len + 2;
    m = n;
    if (n < sz && str[n] == '\n') n--;

    *pos = n;
    *mark = m;

    return 1;
}
#+END_SRC
**** Check For Link
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int check_link(const char *str,
                      size_t pos,
                      size_t sz);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int check_link(const char *str,
                      size_t pos,
                      size_t sz)
{
    size_t n;

    if ((pos - sz) < 5) return 0;

    if (str[pos] != '[' || str[pos+1] != '[') return 0;

    sz -= 1; /* for lookahead */
    pos += 2;

    for (n = pos; n < sz; n++) {
        if (str[n] == '\n') return 0;
        if (str[n] == ']' && str[n + 1] == ']') return 1;
    }

    return 0;
}
#+END_SRC
**** Extract Link
#+NAME: static_funcdefs
#+BEGIN_SRC c
static void extract_link(const char *str,
                         size_t pos,
                         size_t sz,
                         const char **plink,
                         size_t *link_sz,
                         const char **pname,
                         size_t *name_sz,
                         size_t *len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static void extract_link(const char *str,
                         size_t pos,
                         size_t sz,
                         const char **plink,
                         size_t *link_sz,
                         const char **pname,
                         size_t *name_sz,
                         size_t *len)
{
    size_t off;
    size_t n;
    const char *link;
    size_t link_size;
    const char *name;
    size_t name_size;
    size_t tmp;
    size_t start;


    sz -= 1; /* for lookahead */

    start = pos;
    pos += 2;

    off = 2;
    name_size = 0;
    link_size = 0;
    tmp = 0;
    link = NULL;
    name = NULL;
    link = &str[pos];
    for(n = pos; n < sz; n++) {
        off++;
        tmp++;
        if(str[n] == ']' && str[n + 1] == '[') {
            link_size = tmp - 1;
            tmp = 0;
            name = &str[n + 2];
            n++;
            off++;
        } else if(str[n] == ']' && str[n + 1] == ']') {
            name_size = tmp - 1;
            if(name == NULL) { /* name not set, assume type 2 link */
                link_size = name_size;
                name = link;
            }
            off++;
            break;
        }
    }
    *name_sz = name_size;
    *pname = name;
    *link_sz = link_size;
    *plink = link;
    *len = n - start;
}
#+END_SRC
** Parse Comment
Any thing that starts with '# ' (hash + space) is considered
to be a comment, and the line will be ignored.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_comment(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_comment(orgparse_state *state)
{
    size_t start;
    size_t n;
    const char *txt;
    size_t sz;
    size_t *pos;

    txt = state->txt;
    sz = state->sz;
    pos = &state->pos;

    if ((sz - *pos) < 2) return 0;
    if (txt[*pos] != '#') return 0;
    if (txt[*pos + 1] != ' ') return 0;

    start = *pos;

    for (n = start; n < sz; n++) {
        if (txt[n] == '\n') break;
    }

    *pos += (n - start);

    return 1;
}
#+END_SRC
** Parse Command
A 'command' in org mode refers to any line that starts with
'#+'. After this, a string of alphanumeric non-space
characters creates the command name. Following this is an
arbitray number of spaces, followed by the command string.

The =parse_cmd= function will parse and extract the
command, and command string (assuming it is indeed
a command).

#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_cmd(const char *str,
                     size_t sz,
                     const char **cmd,
                     size_t *cmd_len,
                     const char **cmdstr,
                     size_t *cmdstr_len,
                     size_t *total_len);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_cmd(const char *str,
                     size_t sz,
                     const char **cmd,
                     size_t *cmd_len,
                     const char **cmdstr,
                     size_t *cmdstr_len,
                     size_t *total_len)
{
    size_t n;
    const char *pcmdstr;
    const char *pcmd;
    size_t len;
    int mode;
    int rc;

    if (sz < 3) return 0;
    if (str[0] != '#') return 0;
    if (str[1] != '+') return 0;
    if (str[2] == ' ') return 0;

    rc = 0;

    mode = 0;

    pcmd = &str[2];
    pcmdstr = NULL;
    len = 0;

    /* zero out lengths */

    *total_len = 0;
    *cmdstr_len = 0;
    *cmd_len = 0;

    for (n = 2; n < sz; n++) {
        if (str[n] == '\n') {
            *cmdstr_len = len;
            if (mode == 0) {
                *cmd_len = len;
                *cmdstr_len = 0;
                rc = 1;
            }
            break;
        }
        switch (mode) {
            case 0: /* command string */
                if (str[n] == ' ') {
                    mode = 1;
                    *cmd_len = len;
                    len = 0;
                    rc = 1;
                    break;
                }
                len++;
                break;
            case 1:
                if (str[n] != ' ') {
                    mode = 2;
                    len = 1;
                    pcmdstr = &str[n];
                }
                break;
            case 2:
                len++;
                break;
        }
    }

    *cmdstr = pcmdstr;
    *cmd = pcmd;
    *total_len = n * rc;

    return rc;
}
#+END_SRC
** Parse Codeblock
A codeblock is a set of lines smooshed between
'#+BEGIN_SRC' and '#+END_SRC' tags.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_codeblock(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_codeblock(orgparse_state *state)
{
    int rc;
    size_t start;
    size_t cmdlen;
    size_t cmdstrlen;
    const char *cmd;
    const char *cmdstr;
    size_t totallen;
    size_t n;
    int new_block;

    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t *pos;
    int *mode;
    const char **blk;
    size_t *blklen;

    op = state->op;
    txt = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;
    mode = &state->mode;
    blk = &state->blk;
    blklen = &state->len;

    start = *pos;
    cmdlen = 0;
    cmdstrlen = 0;
    totallen = 0;
    rc = parse_cmd(&txt[start],
                   sz,
                   &cmd,
                   &cmdlen,
                   &cmdstr,
                   &cmdstrlen,
                   &totallen);
    new_block = 0;

    if (rc) {
        if (*mode  == 0) {
            if (!strncmp(cmd, "BEGIN_SRC", cmdlen)) {
                *pos += totallen;
                *blk = &txt[*pos + 1];
                *blklen = 0;
                *mode = 1;
                new_block = 1;
            } else {
                /* another command, not a codeblock */
                rc = 0;
            }
        } else if (*mode == 1) {
            if (!strncmp(cmd, "END_SRC", cmdlen)) {
                *pos += totallen;
                *mode = 0;
                if (op->codeblock != NULL) {
                    op->codeblock(ud, *blk, *blklen - 1);
                }
                *blk = NULL;
                *blklen = 0;
            }
        }
    }

    /* Read a line */
    if (*mode == 1 && !new_block) {
        rc = 1;
        for (n = start; n < sz; n++) {
            if (txt[n] == '\n') break;
        }
        *pos += (n - start);
        *blklen += (n - start) + 1;
    }

    return rc;
}
#+END_SRC
** Parse Name
Parses a "#+NAME" command.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_name(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_name(orgparse_state *state)
{
    int rc;
    size_t start;
    size_t cmdlen;
    size_t cmdstrlen;
    const char *cmd;
    const char *cmdstr;
    size_t totallen;

    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t *pos;

    op = state->op;
    txt = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;

    start = *pos;
    cmdlen = 0;
    cmdstrlen = 0;
    totallen = 0;
    rc = parse_cmd(&txt[start],
                   sz,
                   &cmd,
                   &cmdlen,
                   &cmdstr,
                   &cmdstrlen,
                   &totallen);
    if (rc) {
        if (!strncmp(cmd, "NAME:", cmdlen)) {
            if (op->name != NULL) {
                op->name(ud, cmdstr, cmdstrlen);
            }
            *pos += totallen;
        } else rc = 0;
    }

    return rc;
}
#+END_SRC
** Parsing an Aux Block
An aux block is anything inside of a '@!' and '!@'.
For WeeWiki, the idea here is to execute janet code for
dynamic page content. Aux blocks can be both in-line and
multiline. They start out inside of a text block, but have
their own mode for multi-line processing (similar to code
blocks).
*** Beginning a Block
**** Checking for an Aux Block
An aux block can be started at anytime inside of a text
block. The parsing process here must check for any '@!'
roaming around. This is wrapped inside of a function called
=parse_aux_check=. It is called inside of =parse_text=.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_aux_check(const char *str,
                           size_t sz,
                           size_t *pos);
#+END_SRC
At one point, this once also processed the aux block code,
but the function ended up taking too many arguments! Now
it only checks.
#+NAME: functions
#+BEGIN_SRC c
static int parse_aux_check(const char *str,
                           size_t sz,
                           size_t *pos)
{
    size_t n;

    n = *pos;

    if ((sz - n) < 4) return 0;
    if (str[n] != '@') return 0;
    if (str[n + 1] != '!') return 0;

    return 1;
}
#+END_SRC
**** Breaking Out of The Loop
If indeed an aux block has been found, the parsing routine
will immediately break out of the loop and set itself
up to be in aux block mode (mode 2). Any text up to this
point is processed as well.

Return values aren't really being used right now, but
the return value is being set to be 0 (false) to indicate
that the the text has been short-circuited by an aux block.

The code below is done inside of the =parse_text= function.
#+NAME: break_and_begin_aux_block
#+BEGIN_SRC c
if (op->text != NULL && n != mark) {
    op->text(ud, &str[mark], n - mark);
}

*mode = 2;
*len = 0;
*buf = &str[n + 2];

rc = 0;
break;
#+END_SRC
*** Ending it
Once the parse state machine is set to be in aux block mode,
it can only be ended by finding a matching '!@' tag.
**** Do I end?
The only way a aux block ends is with the magic tag '!@'.
This is checked with the function =parse_aux_doiend=.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_aux_doiend(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_aux_doiend(orgparse_state *state)
{
    if ((state->sz - state->pos) < 2) return 0;
    return (state->txt[state->pos] == '!' &&
            state->txt[state->pos + 1] == '@');
}
#+END_SRC
**** Ending The Aux Block
#+NAME: end_the_aux_block
#+BEGIN_SRC c
if (state->op->aux != NULL) {
    state->op->aux(state->ud, state->blk, state->len - 1);
}
state->mode = 0;
state->pos++;
<<handle_auxblock_endofline>>
#+END_SRC
An edge case to handle: what happens when an aux block is at
the end of a line? When this happens, the parser absorbs the
newline character. If this doesn't happen, the text parser
adds an extra newline.
#+NAME: handle_auxblock_endofline
#+BEGIN_SRC c
if ((state->pos + 1) < state->sz &&
    state->txt[state->pos + 1] == '\n') {
    state->pos++;
}
#+END_SRC
**** Adding to aux line
While in aux block mode, the character block length is
increased one character at a time.
#+NAME: increment_aux_line
#+BEGIN_SRC c
state->len++;
#+END_SRC
** Parse Title
Parses the =TITLE= commmand.
#+NAME: static_funcdefs
#+BEGIN_SRC c
static int parse_title(orgparse_state *state);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
static int parse_title(orgparse_state *state)
{
    int rc;
    size_t start;
    size_t cmdlen;
    size_t cmdstrlen;
    const char *cmd;
    const char *cmdstr;
    size_t totallen;


    orgparse *op;
    const char *txt;
    size_t sz;
    void *ud;
    size_t *pos;

    op = state->op;
    txt = state->txt;
    sz = state->sz;
    ud = state->ud;
    pos = &state->pos;

    start = *pos;
    cmdlen = 0;
    cmdstrlen = 0;
    totallen = 0;
    rc = parse_cmd(&txt[start],
                   sz,
                   &cmd,
                   &cmdlen,
                   &cmdstr,
                   &cmdstrlen,
                   &totallen);
    if (rc) {
        if (!strncmp(cmd, "TITLE:", cmdlen)) {
            if (op->title != NULL) {
                op->title(ud, cmdstr, cmdstrlen);
            }
            *pos += totallen;
        }
    }

    return rc;
}
#+END_SRC
